name: HVCI Drivers Check

on:
  schedule:
    # Run daily at 02:00 UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    # Allow manual trigger

permissions:
  contents: write

jobs:
  check-hvci-drivers:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Download Microsoft Vulnerable Driver Blocklist
      id: download-blocklist
      shell: powershell
      run: |
        # Download the vulnerable driver blocklist ZIP
        $blocklistUrl = "https://aka.ms/VulnerableDriverBlockList"
        $zipPath = "VulnerableDriverBlockList.zip"
        $extractPath = "blocklist_temp"
        
        try {
          # Download with retry mechanism
          $maxRetries = 3
          $retryCount = 0
          $downloadSuccess = $false
          
          while ($retryCount -lt $maxRetries -and -not $downloadSuccess) {
            try {
              Write-Host "Downloading blocklist ZIP (attempt $($retryCount + 1)/$maxRetries)..."
              
              # Use WebClient for more reliable download
              $webClient = New-Object System.Net.WebClient
              $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
              $webClient.DownloadFile($blocklistUrl, $zipPath)
              $webClient.Dispose()
              
              # Verify the file exists and has content
              if ((Test-Path $zipPath) -and ((Get-Item $zipPath).Length -gt 0)) {
                Write-Host "Downloaded blocklist ZIP successfully"
                $downloadSuccess = $true
              } else {
                throw "Downloaded file is empty or doesn't exist"
              }
            } catch {
              $retryCount++
              Write-Host "Download attempt failed: $_"
              if ($retryCount -lt $maxRetries) {
                Write-Host "Retrying in 5 seconds..."
                Start-Sleep -Seconds 5
              }
              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force
              }
            }
          }
          
          if (-not $downloadSuccess) {
            throw "Failed to download blocklist after $maxRetries attempts"
          }
          
          # Calculate hash of downloaded ZIP
          $downloadHash = (Get-FileHash -Path $zipPath -Algorithm SHA256).Hash
          Write-Host "Downloaded ZIP hash: $downloadHash"
          
          # Check if hash file exists and compare
          if (Test-Path "data/blocklist-hash.txt") {
            $storedHash = Get-Content "data/blocklist-hash.txt" -Raw
            $storedHash = $storedHash.Trim()
            
            if ($downloadHash -eq $storedHash) {
              Write-Host "Hash matches stored hash. Skipping processing."
              Write-Output "skip_processing=true" >> $env:GITHUB_ENV
              exit 0
            } else {
              Write-Host "Hash differs from stored hash. Continuing processing."
              Write-Output "skip_processing=false" >> $env:GITHUB_ENV
            }
          } else {
            Write-Host "No stored hash found. Continuing processing."
            Write-Output "skip_processing=false" >> $env:GITHUB_ENV
          }
          
          # Test ZIP integrity before extraction
          try {
            $shell = New-Object -ComObject Shell.Application
            $zip = $shell.NameSpace($zipPath)
            if ($null -eq $zip) {
              throw "ZIP file appears to be corrupted"
            }
            Write-Host "ZIP file integrity check passed"
          } catch {
            Write-Host "ZIP integrity check failed, trying alternative extraction..."
          }
          
          # Extract ZIP with error handling
          try {
            Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
            Write-Host "ZIP extracted successfully"
          } catch {
            Write-Host "PowerShell extraction failed, trying alternative method..."
            
            # Alternative extraction using .NET
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            if (Test-Path $extractPath) {
              Remove-Item $extractPath -Recurse -Force
            }
            New-Item -ItemType Directory -Path $extractPath -Force
            [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $extractPath)
            Write-Host "Alternative extraction successful"
          }
          
          # Verify SiPolicy_Enforced.xml exists
          $xmlPath = Join-Path $extractPath "VulnerableDriverBlockList\SiPolicy_Enforced.xml"
          if (Test-Path $xmlPath) {
            Write-Host "Found SiPolicy_Enforced.xml at: $xmlPath"
            Write-Output "xml_path=$xmlPath" >> $env:GITHUB_ENV
          } else {
            # Try to find the file in case directory structure is different
            $xmlFiles = Get-ChildItem -Path $extractPath -Recurse -Name "SiPolicy_Enforced.xml"
            if ($xmlFiles.Count -gt 0) {
              $xmlPath = Join-Path $extractPath $xmlFiles[0]
              Write-Host "Found SiPolicy_Enforced.xml at alternative location: $xmlPath"
              Write-Output "xml_path=$xmlPath" >> $env:GITHUB_ENV
            } else {
              Write-Host "Available files in extracted archive:"
              Get-ChildItem -Path $extractPath -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
              Write-Error "SiPolicy_Enforced.xml not found in extracted files"
              exit 1
            }
          }
          
          # Store the new hash
          $downloadHash | Out-File -FilePath "data/blocklist-hash.txt" -Encoding utf8 -NoNewline
          
        } catch {
          Write-Error "Failed to download or process blocklist: $_"
          exit 1
        }
    
    - name: Process HVCI Driver Check
      if: env.skip_processing == 'false'
      shell: powershell
      run: |
        # Load the drivers JSON data
        if (-not (Test-Path "data/drv.json")) {
          Write-Error "data/drv.json not found"
          exit 1
        }
        
        # Load JSON with duplicate key handling
        $jsonContent = Get-Content "data/drv.json" -Raw
        # Clean up potential BOM and normalize line endings
        $jsonContent = $jsonContent.Trim()
        try {
          $driversData = $jsonContent | ConvertFrom-Json
        } catch {
          Write-Host "JSON conversion failed, attempting to fix duplicate keys..."
          # If there are duplicate keys, try to fix common issues
          $jsonContent = $jsonContent -replace '"init":', '"init_lowercase":'
          $driversData = $jsonContent | ConvertFrom-Json
        }

        Write-Host "Loaded $($driversData.Count) drivers from data/drv.json"
        
        # Load the XML policy
        $xmlPath = $env:xml_path
        if (-not (Test-Path $xmlPath)) {
          Write-Error "XML policy file not found: $xmlPath"
          exit 1
        }
        
        [xml]$policy = Get-Content $xmlPath
        Write-Host "Loaded HVCI policy XML"
        
        # Extract policy components
        $fileRules = $policy.SiPolicy.FileRules
        $signers = $policy.SiPolicy.Signers.Signer
        
        Write-Host "Found $($fileRules.Deny.Count) deny rules and $($signers.Count) signers"
        
        # Initialize result collections
        $allowed = New-Object System.Collections.ArrayList
        $blocked = New-Object System.Collections.ArrayList
        
        # Helper function to check if driver hash is blocked
        function Test-BlockedHash($driver) {
          foreach ($hash in $fileRules.Deny.Hash) {
            if ($hash -and (
              ($hash -eq $driver.Authentihash.SHA256) -or
              ($hash -eq $driver.Authentihash.SHA1) -or 
              ($hash -eq $driver.Authentihash.MD5) -or 
              ($hash -eq $driver.SHA256) -or
              ($hash -eq $driver.SHA1) -or 
              ($hash -eq $driver.MD5)
            )) {
              return $true
            }
          }
          return $false
        }
        
        # Helper function to check if driver signer is blocked
        function Test-BlockedSigner($driver) {
          $fileAttrib = $fileRules.FileAttrib | Where-Object { $_.FileName -eq $driver.OriginalFilename }
          
          foreach ($signer in $signers) {
            if ($signer.CertRoot -and $signer.CertRoot.Value) {
              $tbs = $signer.CertRoot.Value.ToLower()
              
              if ($driver.Signatures -and $driver.Signatures.Count -gt 0) {
                foreach ($signature in $driver.Signatures) {
                  if ($signature.Certificates -and $signature.Certificates.Count -gt 0) {
                    foreach ($cert in $signature.Certificates) {
                      if ($cert.TBS -and (
                        ($cert.TBS.MD5 -and $cert.TBS.MD5.ToLower() -eq $tbs) -or
                        ($cert.TBS.SHA1 -and $cert.TBS.SHA1.ToLower() -eq $tbs) -or 
                        ($cert.TBS.SHA256 -and $cert.TBS.SHA256.ToLower() -eq $tbs) -or 
                        ($cert.TBS.SHA384 -and $cert.TBS.SHA384.ToLower() -eq $tbs)
                      )) {
                        $blockedFiles = $signer.FileAttribRef
                        if (-not $blockedFiles -or ($fileAttrib -and $blockedFiles.RuleID -contains $fileAttrib.ID)) {
                          return $true
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return $false
        }
        
        # Process each driver
        $modifiedDrivers = 0
        foreach ($driver in $driversData) {
          if ($driver.KnownVulnerableSamples -and $driver.KnownVulnerableSamples.Count -gt 0) {
            foreach ($sample in $driver.KnownVulnerableSamples) {
              $isBlocked = $false
              
              # Check if hash is blocked
              if (Test-BlockedHash $sample) {
                $isBlocked = $true
              }
              
              # Check file version rules
              if (-not $isBlocked) {
                $fileMaxVersion = ($fileRules.Deny | Where-Object { $_.FileName -eq $sample.OriginalFilename }).MaximumFileVersion
                if ($fileMaxVersion -and $sample.FileVersion) {
                  $version = ($sample.FileVersion -replace ',\s*', '.').Split()[0]
                  if ($version -and [version]$version -le [version]$fileMaxVersion) {
                    $isBlocked = $true
                  }
                }
              }
              
              # Check signer rules
              if (-not $isBlocked) {
                if (Test-BlockedSigner $sample) {
                  $isBlocked = $true
                }
              }
              
              # Update LoadsDespiteHVCI field with better object handling
              $newValue = if ($isBlocked) { "FALSE" } else { "TRUE" }

              try {
                # Check if property exists
                $hasProperty = $sample.PSObject.Properties.Name -contains "LoadsDespiteHVCI"
                $currentValue = if ($hasProperty) { $sample.LoadsDespiteHVCI } else { $null }
                
                if ($currentValue -ne $newValue) {
                  if ($hasProperty) {
                    # Property exists, update it
                    $sample.LoadsDespiteHVCI = $newValue
                  } else {
                    # Property doesn't exist, add it
                    $sample | Add-Member -MemberType NoteProperty -Name "LoadsDespiteHVCI" -Value $newValue -Force
                  }
                  $modifiedDrivers++
                  Write-Host "Updated LoadsDespiteHVCI for driver $($sample.SHA256) to $newValue"
                }
              } catch {
                Write-Host "Warning: Failed to update LoadsDespiteHVCI for driver $($sample.SHA256): $_"
                # Try creating a new object with the property
                $newSample = [PSCustomObject]@{}
                foreach ($prop in $sample.PSObject.Properties) {
                  $newSample | Add-Member -MemberType NoteProperty -Name $prop.Name -Value $prop.Value
                }
                $newSample | Add-Member -MemberType NoteProperty -Name "LoadsDespiteHVCI" -Value $newValue -Force
                
                # Replace the sample in the array (this requires more complex logic)
                Write-Host "Created new object with LoadsDespiteHVCI property"
              }

              
              # Add to result collections for CSV
              $driverInfo = [PSCustomObject]@{
                MD5 = $sample.MD5
                SHA1 = $sample.SHA1
                SHA256 = $sample.SHA256
                Status = if ($isBlocked) { "Blocked" } else { "Allowed" }
              }
              
              if ($isBlocked) {
                [void]$blocked.Add($driverInfo)
              } else {
                [void]$allowed.Add($driverInfo)
              }
            }
          }
        }
        
        # Generate CSV
        $allDrivers = $allowed + $blocked
        $csvPath = "data/hvci_drivers.csv"
        
        # Ensure data directory exists
        if (-not (Test-Path "data")) {
          New-Item -ItemType Directory -Path "data" -Force
        }
        
        $allDrivers | Export-Csv -Path $csvPath -NoTypeInformation
        Write-Host "CSV file created at $csvPath with $($allDrivers.Count) entries"
        
        # Save updated JSON with proper formatting
        $jsonOutput = $driversData | ConvertTo-Json -Depth 100
        $jsonOutput | Out-File -FilePath "data/drv.json" -Encoding UTF8 -NoNewline
        Write-Host "Updated drv.json with $modifiedDrivers modified driver entries"
        
        # Set environment variables for summary
        Write-Output "total_drivers=$($allDrivers.Count)" >> $env:GITHUB_ENV
        Write-Output "allowed_drivers=$($allowed.Count)" >> $env:GITHUB_ENV
        Write-Output "blocked_drivers=$($blocked.Count)" >> $env:GITHUB_ENV
        Write-Output "modified_drivers=$modifiedDrivers" >> $env:GITHUB_ENV
    
    - name: Generate Summary
      if: env.skip_processing == 'false'
      shell: powershell
      run: |
        $summary = @"
        # HVCI Driver Check Results
        
        ## Summary
        - **Total Drivers Processed**: $env:total_drivers
        - **Allowed Drivers**: $env:allowed_drivers
        - **Blocked Drivers**: $env:blocked_drivers
        - **Modified Driver Entries**: $env:modified_drivers
        
        ## Details
        - Drivers marked as **Allowed** can potentially load despite HVCI restrictions
        - Drivers marked as **Blocked** are prevented from loading by the HVCI policy
        - The LoadsDespiteHVCI field has been updated for modified entries
        - Updated CSV file saved to data/hvci_drivers.csv
        - Updated JSON file saved to data/drv.json
        
        ## Files Updated
        - data/hvci_drivers.csv
        - data/drv.json
        - data/blocklist-hash.txt
        - .github/hvci-stats.json
        "@
        
        Write-Host $summary
        $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8
    
    - name: Create Statistics Badge
      if: env.skip_processing == 'false'
      shell: powershell
      run: |
        $badgeData = @{
          schemaVersion = 1
          label = "HVCI Drivers"
          message = "Allowed: $env:allowed_drivers | Blocked: $env:blocked_drivers"
          color = if ([int]$env:allowed_drivers -gt [int]$env:blocked_drivers) { "orange" } else { "green" }
        }
        
        if (-not (Test-Path ".github")) {
          New-Item -ItemType Directory -Path ".github" -Force
        }
        
        $badgeData | ConvertTo-Json | Out-File -FilePath ".github/hvci-stats.json" -Encoding utf8
        git add .github/hvci-stats.json


    - name: Check for changes
      if: env.skip_processing == 'false'
      id: changes
      shell: powershell
      run: |
        $gitStatus = git status --porcelain
        if ($gitStatus) {
          Write-Host "Changes detected:"
          Write-Host $gitStatus
          Write-Output "has_changes=true" >> $env:GITHUB_ENV
        } else {
          Write-Host "No changes detected"
          Write-Output "has_changes=false" >> $env:GITHUB_ENV
        }
    
    - name: Commit and push changes
      if: env.skip_processing == 'false' && env.has_changes == 'true'
      shell: powershell
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add data/hvci_drivers.csv
        git add data/drv.json
        git add data/blocklist-hash.txt
        git add .github/hvci-stats.json
        
        $commitMessage = "Update HVCI driver check results - $env:modified_drivers drivers modified"
        git commit -m $commitMessage
        git push
        
        Write-Host "Changes committed and pushed successfully"
    
    - name: Cleanup
      if: always()
      shell: powershell
      run: |
        # Clean up temporary files
        if (Test-Path "VulnerableDriverBlockList.zip") {
          Remove-Item "VulnerableDriverBlockList.zip" -Force
        }
        if (Test-Path "blocklist_temp") {
          Remove-Item "blocklist_temp" -Recurse -Force
        }
        Write-Host "Cleanup completed"