name: "Driver Tagging (Python)"

on:
  workflow_dispatch: # Manual trigger
  workflow_run:
    workflows: ["Update LOLDrivers Data"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  actions: read

jobs:
  check_prerequisites:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
    - name: Check if workflow should run
      id: check
      run: |
        echo "Event: ${{ github.event_name }}"
        
        if [ "${{ github.event_name }}" != "workflow_run" ]; then
          echo "Manual trigger - running"
          echo "should_run=true" >> $GITHUB_OUTPUT
        elif [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
          echo "Previous workflow successful - running"
          echo "should_run=true" >> $GITHUB_OUTPUT
        else
          echo "Previous workflow failed - skipping"
          echo "should_run=false" >> $GITHUB_OUTPUT
        fi

  download_blocklist:
    runs-on: ubuntu-latest
    needs: check_prerequisites
    if: needs.check_prerequisites.outputs.should_run == 'true'
    outputs:
      hash_changed: ${{ steps.download.outputs.hash_changed }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Download and check Microsoft HVCI blocklist
      id: download
      run: |
        echo "Downloading Microsoft HVCI Vulnerable Driver Blocklist..."
        
        # Download blocklist
        wget -O VulnerableDriverBlockList.zip "https://aka.ms/VulnerableDriverBlockList"
        
        # Calculate current hash
        current_hash=$(sha256sum VulnerableDriverBlockList.zip | cut -d' ' -f1)
        echo "Current hash: $current_hash"
        
        # Check previous hash
        if [ -f "data/blocklist-hash.txt" ]; then
          # Look for a valid hash (64 hex characters)
          if grep -q "^[A-Fa-f0-9]\{64\}$" data/blocklist-hash.txt; then
            previous_hash=$(grep "^[A-Fa-f0-9]\{64\}$" data/blocklist-hash.txt | head -1)
            echo "Previous hash: $previous_hash"
            
            if [ "$current_hash" = "$previous_hash" ]; then
              echo "Hash unchanged - skipping analysis"
              echo "hash_changed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          else
            echo "No valid hash found in blocklist-hash.txt - proceeding with first run"
          fi
        else
          echo "No hash file found - proceeding with first run"
        fi
        
        echo "Hash changed or first run - proceeding"
        echo "$current_hash" > data/blocklist-hash.txt
        echo "hash_changed=true" >> $GITHUB_OUTPUT
        
    - name: Upload blocklist and hash
      if: steps.download.outputs.hash_changed == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: blocklist
        path: |
          VulnerableDriverBlockList.zip
          data/blocklist-hash.txt

  analyze_hvci:
    runs-on: ubuntu-latest
    needs: download_blocklist
    if: needs.download_blocklist.outputs.hash_changed == 'true'
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install lxml requests
        
    - name: Download blocklist
      uses: actions/download-artifact@v4
      with:
        name: blocklist
        
    - name: Analyze HVCI policy
      run: |
        cat > analyze_hvci.py << 'EOF'
        #!/usr/bin/env python3
        import json
        import zipfile
        import xml.etree.ElementTree as ET
        import re
        import csv
        from pathlib import Path
        
        def extract_blocklist():
            """Extract the ZIP and find the XML policy file"""
            with zipfile.ZipFile('VulnerableDriverBlockList.zip', 'r') as zip_ref:
                zip_ref.extractall('blocklist')
            
            # Find XML files
            xml_files = list(Path('blocklist').rglob('*.xml'))
            print(f"Found {len(xml_files)} XML files")
            
            # Look for SiPolicy XML
            target_xml = None
            for xml_file in xml_files:
                if 'SiPolicy' in xml_file.name:
                    target_xml = xml_file
                    break
            
            if not target_xml and xml_files:
                target_xml = xml_files[0]
                
            if not target_xml:
                raise FileNotFoundError("No XML policy file found")
                
            print(f"Using XML file: {target_xml}")
            return target_xml
        
        def parse_hvci_policy(xml_file):
            """Parse HVCI policy and extract blocked items"""
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            # Find namespace
            ns = {'si': 'urn:schemas-microsoft-com:sipolicy'}
            if root.tag.startswith('{'):
                ns_uri = root.tag.split('}')[0][1:]
                ns = {'si': ns_uri}
            
            blocked_hashes = {}
            blocked_signers = {}
            blocked_filenames = {}
            
            # Extract denied file rules
            for deny_rule in root.findall('.//si:Deny', ns):
                # Hash rules
                hash_attr = deny_rule.get('Hash')
                if hash_attr:
                    clean_hash = re.sub(r'[^A-F0-9]', '', hash_attr.upper())
                    if len(clean_hash) in [32, 40, 64]:  # MD5, SHA1, SHA256
                        hash_type = {32: 'MD5', 40: 'SHA1', 64: 'SHA256'}[len(clean_hash)]
                        blocked_hashes[clean_hash] = hash_type
                
                # Filename rules
                filename = deny_rule.get('FileName')
                if filename:
                    max_version = deny_rule.get('MaximumFileVersion')
                    blocked_filenames[filename] = max_version
            
            # Extract signers
            for signer in root.findall('.//si:Signer', ns):
                cert_root = signer.find('si:CertRoot', ns)
                if cert_root is not None:
                    tbs_hash = cert_root.get('Value', '').lower()
                    if tbs_hash:
                        blocked_signers[tbs_hash] = signer.get('Name', 'Unknown')
            
            print(f"Extracted: {len(blocked_hashes)} hashes, {len(blocked_signers)} signers, {len(blocked_filenames)} filenames")
            return blocked_hashes, blocked_signers, blocked_filenames
        
        def analyze_drivers(blocked_hashes, blocked_signers, blocked_filenames):
            """Analyze drivers against HVCI policy"""
            
            # Load local drivers data
            drv_path = Path('data/drv.json')
            if not drv_path.exists():
                drv_path = Path('data/drvj.json')
            
            with open(drv_path, 'r') as f:
                drivers = json.load(f)
            
            results = []
            
            for driver in drivers:
                if not driver.get('KnownVulnerableSamples'):
                    continue
                    
                for sample in driver['KnownVulnerableSamples']:
                    # Check hashes
                    is_blocked = False
                    block_reason = "Allowed by HVCI"
                    matched_detail = "N/A"
                    
                    # Check all hash types
                    for hash_field in ['MD5', 'SHA1', 'SHA256']:
                        if sample.get(hash_field):
                            clean_hash = sample[hash_field].upper()
                            if clean_hash in blocked_hashes:
                                is_blocked = True
                                block_reason = f"Hash blocked ({hash_field})"
                                matched_detail = clean_hash
                                break
                    
                    # Check Authentihash if not blocked by standard hash
                    if not is_blocked and sample.get('Authentihash'):
                        for hash_field in ['MD5', 'SHA1', 'SHA256']:
                            auth_hash = sample['Authentihash'].get(hash_field)
                            if auth_hash:
                                clean_hash = auth_hash.upper()
                                if clean_hash in blocked_hashes:
                                    is_blocked = True
                                    block_reason = f"Authentihash blocked ({hash_field})"
                                    matched_detail = clean_hash
                                    break
                    
                    # Check filename/tags
                    if not is_blocked and sample.get('Tags'):
                        for tag in sample['Tags']:
                            if tag in blocked_filenames:
                                is_blocked = True
                                block_reason = "Filename blocked"
                                matched_detail = tag
                                break
                    
                    # Certificate validation (simplified)
                    cert_status = "Unknown"
                    signatures = sample.get('Signatures')
                    if signatures:
                        # Handle both dict and list formats
                        if isinstance(signatures, dict) and signatures.get('Certificates'):
                            cert_status = "Valid"
                        elif isinstance(signatures, list) and len(signatures) > 0:
                            # Check if any signature has certificates
                            for sig in signatures:
                                if isinstance(sig, dict) and sig.get('Certificates'):
                                    cert_status = "Valid"
                                    break
                    
                    results.append({
                        'MD5': sample.get('MD5', 'N/A'),
                        'SHA1': sample.get('SHA1', 'N/A'),
                        'SHA256': sample.get('SHA256', 'N/A'),
                        'Status': 'Blocked' if is_blocked else 'Allowed',
                        'BlockReason': block_reason,
                        'MatchedDetail': matched_detail,
                        'CertificateStatus': cert_status,
                        'DriverId': driver.get('Id', 'Unknown'),
                        'Company': sample.get('Company', 'Unknown'),
                        'Filename': sample.get('Filename', sample.get('OriginalFilename', 'Unknown')),
                        'FileVersion': sample.get('FileVersion', 'Unknown')
                    })
            
            return results
        
        def main():
            print("Starting HVCI analysis...")
            
            # Extract and parse policy
            xml_file = extract_blocklist()
            blocked_hashes, blocked_signers, blocked_filenames = parse_hvci_policy(xml_file)
            
            # Analyze drivers
            results = analyze_drivers(blocked_hashes, blocked_signers, blocked_filenames)
            
            # Save results
            with open('hvci_results.csv', 'w', newline='') as f:
                if results:
                    writer = csv.DictWriter(f, fieldnames=results[0].keys())
                    writer.writeheader()
                    writer.writerows(results)
            
            blocked_count = sum(1 for r in results if r['Status'] == 'Blocked')
            print(f"Analysis complete: {len(results)} drivers, {blocked_count} blocked")
            
            # Create summary
            summary = {
                'total_drivers': len(results),
                'blocked_drivers': blocked_count,
                'allowed_drivers': len(results) - blocked_count,
                'policy_components': {
                    'blocked_hashes': len(blocked_hashes),
                    'blocked_signers': len(blocked_signers),
                    'blocked_filenames': len(blocked_filenames)
                }
            }
            
            with open('hvci_summary.json', 'w') as f:
                json.dump(summary, f, indent=2)
        
        if __name__ == '__main__':
            main()
        EOF
        
        python analyze_hvci.py
        
    - name: Upload analysis results
      uses: actions/upload-artifact@v4
      with:
        name: hvci-analysis
        path: |
          hvci_results.csv
          hvci_summary.json

  update_certificates:
    runs-on: windows-latest
    needs: analyze_hvci
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Download analysis results
      uses: actions/download-artifact@v4
      with:
        name: hvci-analysis
        
    - name: Create drivers directory
      run: |
        mkdir -p data/drivers
        
    - name: Download and validate certificates with PowerShell
      shell: powershell
      run: |
        # PowerShell script to download and validate driver certificates
        $ErrorActionPreference = "Continue"
        
        Write-Host "Starting driver download and certificate validation process..."
        
        # Create drivers directory if it doesn't exist
        $driversDir = "data/drivers"
        if (-not (Test-Path $driversDir)) {
            New-Item -ItemType Directory -Path $driversDir -Force | Out-Null
        }
        
        # Function to download a driver file
        function Get-DriverFile {
            param(
                [string]$MD5Hash,
                [string]$TargetDir,
                [int]$MaxRetries = 3
            )
            
            $fileName = "$MD5Hash.bin"
            $filePath = Join-Path $TargetDir $fileName
            $downloadUrl = "https://github.com/magicsword-io/LOLDrivers/raw/main/drivers/$fileName"
            
            # Check if file already exists
            if (Test-Path $filePath) {
                Write-Host "Driver already exists: $fileName" -ForegroundColor Green
                return $filePath
            }
            
            # Download the driver file
            $retryCount = 0
            while ($retryCount -lt $MaxRetries) {
                try {
                    Write-Host "Downloading: $fileName (attempt $($retryCount + 1))" -ForegroundColor Yellow
                    Invoke-WebRequest -Uri $downloadUrl -OutFile $filePath -TimeoutSec 30 -ErrorAction Stop
                    
                    # Verify file was downloaded and has content
                    if ((Test-Path $filePath) -and ((Get-Item $filePath).Length -gt 0)) {
                        Write-Host "Successfully downloaded: $fileName" -ForegroundColor Green
                        return $filePath
                    } else {
                        Remove-Item $filePath -Force -ErrorAction SilentlyContinue
                        throw "Downloaded file is empty or invalid"
                    }
                }
                catch {
                    $retryCount++
                    Write-Host "Download failed for $fileName (attempt $retryCount): $($_.Exception.Message)" -ForegroundColor Red
                    
                    if ($retryCount -lt $MaxRetries) {
                        Start-Sleep -Seconds 2
                    }
                }
            }
            
            Write-Host "Failed to download after $MaxRetries attempts: $fileName" -ForegroundColor Red
            return $null
        }
        
        # Function to validate a single certificate
        function Test-DriverCertificate {
            param(
                [string]$FilePath,
                [int]$TimeoutSeconds = 10
            )
            
            try {
                if (-not (Test-Path $FilePath)) {
                    return @{
                        Status = "Unknown"
                        Reason = "File not found"
                        Details = ""
                    }
                }
                
                # Get the certificate
                $signature = Get-AuthenticodeSignature $FilePath -ErrorAction SilentlyContinue
                
                if ($null -eq $signature) {
                    return @{
                        Status = "Unknown"
                        Reason = "Failed to get signature"
                        Details = ""
                    }
                }
                
                # Check signature status first
                if ($signature.Status -eq "NotSigned") {
                    return @{
                        Status = "Unknown"
                        Reason = "File is not signed"
                        Details = ""
                    }
                }
                
                if ($signature.Status -eq "HashMismatch") {
                    return @{
                        Status = "Invalid"
                        Reason = "Hash mismatch - file may be corrupted"
                        Details = ""
                    }
                }
                
                $cert = $signature.SignerCertificate
                
                if ($null -eq $cert) {
                    return @{
                        Status = "Unknown"
                        Reason = "No certificate found in signature"
                        Details = ""
                    }
                }
                
                # Check if certificate is expired
                $now = Get-Date
                if ($cert.NotAfter -lt $now) {
                    return @{
                        Status = "Expired"
                        Reason = "Certificate has expired"
                        Details = "Expired on: $($cert.NotAfter.ToString('yyyy-MM-dd'))"
                    }
                }
                
                if ($cert.NotBefore -gt $now) {
                    return @{
                        Status = "Invalid"
                        Reason = "Certificate not yet valid"
                        Details = "Valid from: $($cert.NotBefore.ToString('yyyy-MM-dd'))"
                    }
                }
                
                # Check revocation status
                try {
                    $chain = New-Object System.Security.Cryptography.X509Certificates.X509Chain
                    $chain.ChainPolicy.RevocationMode = [System.Security.Cryptography.X509Certificates.X509RevocationMode]::Online
                    $chain.ChainPolicy.RevocationFlag = [System.Security.Cryptography.X509Certificates.X509RevocationFlag]::EntireChain
                    $chain.ChainPolicy.VerificationFlags = [System.Security.Cryptography.X509Certificates.X509VerificationFlags]::NoFlag
                    $chain.ChainPolicy.UrlRetrievalTimeout = [TimeSpan]::FromSeconds($TimeoutSeconds)
                    
                    $valid = $chain.Build($cert)
                    
                    if ($valid) {
                        return @{
                            Status = "Valid"
                            Reason = "Certificate is valid and not revoked"
                            Details = "Subject: $($cert.Subject)"
                        }
                    } else {
                        $statusDetails = @()
                        foreach ($status in $chain.ChainStatus) {
                            $statusDetails += "$($status.Status): $($status.StatusInformation.Trim())"
                            
                            # Check for specific revocation status
                            if ($status.Status -eq "Revoked") {
                                return @{
                                    Status = "Revoked"
                                    Reason = "Certificate has been revoked"
                                    Details = $status.StatusInformation.Trim()
                                }
                            }
                        }
                        
                        return @{
                            Status = "Invalid"
                            Reason = "Certificate validation failed"
                            Details = ($statusDetails -join "; ")
                        }
                    }
                } catch {
                    # If online revocation check fails, fall back to basic validation
                    if ($signature.Status -eq "Valid") {
                        return @{
                            Status = "Valid"
                            Reason = "Certificate appears valid (revocation check failed)"
                            Details = "Subject: $($cert.Subject)"
                        }
                    } else {
                        return @{
                            Status = "Unknown"
                            Reason = "Certificate validation error"
                            Details = $_.Exception.Message
                        }
                    }
                }
            }
            catch {
                return @{
                    Status = "Unknown"
                    Reason = "Error during validation"
                    Details = $_.Exception.Message
                }
            }
        }
        
        # Load the driver data to get file paths
        $drvPath = "data/drv.json"
        if (-not (Test-Path $drvPath)) {
            $drvPath = "data/drvj.json"
        }
        
        if (-not (Test-Path $drvPath)) {
            Write-Host "Driver data file not found"
            exit 1
        }
        
        # Load JSON with duplicate key handling
        $jsonContent = Get-Content $drvPath -Raw
        try {
            $driversData = $jsonContent | ConvertFrom-Json
        } catch {
            # Handle duplicate keys by using case-insensitive approach
            Write-Host "JSON parsing failed due to duplicate keys, attempting cleanup..." -ForegroundColor Yellow
            
            # Simple approach: remove duplicate case variants (keep first occurrence)
            $lines = $jsonContent -split "`n"
            $cleanedLines = @()
            $seenKeys = @{}
            
            foreach ($line in $lines) {
                if ($line -match '^\s*"([^"]+)"\s*:') {
                    $key = $matches[1].ToLower()
                    if (-not $seenKeys.ContainsKey($key)) {
                        $seenKeys[$key] = $true
                        $cleanedLines += $line
                    } else {
                        Write-Host "Skipping duplicate key: $($matches[1])" -ForegroundColor Yellow
                    }
                } else {
                    $cleanedLines += $line
                }
            }
            
            $cleanedJson = $cleanedLines -join "`n"
            $driversData = $cleanedJson | ConvertFrom-Json
        }
        $validationResults = @{}
        $downloadStats = @{
            attempted = 0
            successful = 0
            failed = 0
            skipped = 0
        }
        
        Write-Host "Processing $($driversData.Count) drivers..."
        
        $processedCount = 0
        $totalSamples = 0
        
        # First pass: count total samples
        foreach ($driver in $driversData) {
            if ($driver.KnownVulnerableSamples) {
                $totalSamples += $driver.KnownVulnerableSamples.Count
            }
        }
        
        Write-Host "Total samples to process: $totalSamples"
        
        foreach ($driver in $driversData) {
            if (-not $driver.KnownVulnerableSamples) {
                continue
            }
            
            foreach ($sample in $driver.KnownVulnerableSamples) {
                $processedCount++
                
                # Get MD5 hash for download
                $md5Hash = $sample.MD5
                if (-not $md5Hash) {
                    Write-Host "No MD5 hash found for sample $processedCount, skipping..." -ForegroundColor Yellow
                    $downloadStats.skipped++
                    continue
                }
                
                # Use SHA256 as primary identifier for results, fall back to MD5
                $sampleId = if ($sample.SHA256) { $sample.SHA256.ToUpper() } else { $md5Hash.ToUpper() }
                
                # Download the driver file
                $downloadStats.attempted++
                $driverPath = Get-DriverFile -MD5Hash $md5Hash -TargetDir $driversDir
                
                if ($null -ne $driverPath) {
                    $downloadStats.successful++
                    
                    # Validate certificate
                    Write-Host "Validating certificate for: $md5Hash.bin" -ForegroundColor Cyan
                    $validationResult = Test-DriverCertificate -FilePath $driverPath -TimeoutSeconds 15
                    
                    $validationResults[$sampleId] = @{
                        status = $validationResult.Status
                        reason = $validationResult.Reason
                        details = $validationResult.Details
                        file_path = $driverPath
                        md5_hash = $md5Hash
                    }
                    
                    Write-Host "Certificate status for $($md5Hash): $($validationResult.Status)" -ForegroundColor $(
                        switch ($validationResult.Status) {
                            "Valid" { "Green" }
                            "Expired" { "Yellow" }
                            "Revoked" { "Red" }
                            "Invalid" { "Red" }
                            default { "Gray" }
                        }
                    )
                } else {
                    $downloadStats.failed++
                    
                    # Still record the sample but mark as unknown
                    $validationResults[$sampleId] = @{
                        status = "Unknown"
                        reason = "Failed to download driver file"
                        details = "Download failed after multiple attempts"
                        file_path = $null
                        md5_hash = $md5Hash
                    }
                }
                
                # Progress reporting
                if ($processedCount % 50 -eq 0 -or $processedCount -eq $totalSamples) {
                    $percentage = [math]::Round(($processedCount / $totalSamples) * 100, 1)
                    Write-Host "Progress: $processedCount/$totalSamples ($percentage%) - Downloaded: $($downloadStats.successful), Failed: $($downloadStats.failed)" -ForegroundColor Blue
                }
            }
        }
        
        Write-Host ""
        Write-Host "=== Certificate Validation Summary ===" -ForegroundColor Green
        Write-Host "Total samples processed: $processedCount" -ForegroundColor Cyan
        Write-Host "Download attempts: $($downloadStats.attempted)" -ForegroundColor Cyan
        Write-Host "Successful downloads: $($downloadStats.successful)" -ForegroundColor Green
        Write-Host "Failed downloads: $($downloadStats.failed)" -ForegroundColor Red
        Write-Host "Skipped (no MD5): $($downloadStats.skipped)" -ForegroundColor Yellow
        
        # Certificate status distribution
        $statusCounts = @{}
        foreach ($result in $validationResults.Values) {
            $status = $result.status
            if ($statusCounts.ContainsKey($status)) {
                $statusCounts[$status] = $statusCounts[$status] + 1
            } else {
                $statusCounts[$status] = 1
            }
        }
        
        Write-Host ""
        Write-Host "Certificate Status Distribution:" -ForegroundColor Yellow
        foreach ($status in $statusCounts.Keys | Sort-Object) {
            $count = $statusCounts[$status]
            Write-Host "  $status : $count" -ForegroundColor White
        }
        
        # Save validation results as JSON for Python script
        $resultsJson = @{
            validation_results = $validationResults
            download_statistics = $downloadStats
            timestamp = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
            processed_count = $processedCount
            certificate_distribution = $statusCounts
        }
        
        $resultsJson | ConvertTo-Json -Depth 10 | Out-File -FilePath "certificate_validation_results.json" -Encoding UTF8
        Write-Host ""
        Write-Host "Validation results saved to certificate_validation_results.json" -ForegroundColor Green
        
    - name: Update certificate attributes
      run: |
        # Create Python script using echo commands (Windows compatible)
        echo '#!/usr/bin/env python3' > update_certificates.py
        echo 'import json' >> update_certificates.py
        echo 'import csv' >> update_certificates.py
        echo 'from pathlib import Path' >> update_certificates.py
        echo '' >> update_certificates.py
        echo 'def load_analysis_results():' >> update_certificates.py
        echo '    """Load HVCI analysis results and certificate validation"""' >> update_certificates.py
        echo '    results = {}' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Load HVCI results' >> update_certificates.py
        echo '    with open("hvci_results.csv", "r") as f:' >> update_certificates.py
        echo '        reader = csv.DictReader(f)' >> update_certificates.py
        echo '        for row in reader:' >> update_certificates.py
        echo '            # Map by hash' >> update_certificates.py
        echo '            for hash_field in ["MD5", "SHA1", "SHA256"]:' >> update_certificates.py
        echo '                hash_value = row.get(hash_field)' >> update_certificates.py
        echo '                if hash_value and hash_value != "N/A":' >> update_certificates.py
        echo '                    results[hash_value.upper()] = {' >> update_certificates.py
        echo '                        "status": row["CertificateStatus"],' >> update_certificates.py
        echo '                        "hvci_status": row["Status"]' >> update_certificates.py
        echo '                    }' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Load PowerShell certificate validation results' >> update_certificates.py
        echo '    try:' >> update_certificates.py
        echo '        with open("certificate_validation_results.json", "r") as f:' >> update_certificates.py
        echo '            cert_data = json.load(f)' >> update_certificates.py
        echo '            cert_results = cert_data.get("validation_results", {})' >> update_certificates.py
        echo '            download_stats = cert_data.get("download_statistics", {})' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '            print(f"PowerShell validation summary:")' >> update_certificates.py
        echo '            print(f"  - Download attempts: {download_stats.get(\"attempted\", 0)}")' >> update_certificates.py
        echo '            print(f"  - Successful downloads: {download_stats.get(\"successful\", 0)}")' >> update_certificates.py
        echo '            print(f"  - Failed downloads: {download_stats.get(\"failed\", 0)}")' >> update_certificates.py
        echo '            print(f"  - Skipped (no MD5): {download_stats.get(\"skipped\", 0)}")' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '            # Update results with PowerShell validation' >> update_certificates.py
        echo '            for hash_value, cert_info in cert_results.items():' >> update_certificates.py
        echo '                if hash_value in results:' >> update_certificates.py
        echo '                    # Use PowerShell validation result if available' >> update_certificates.py
        echo '                    results[hash_value]["status"] = cert_info["status"]' >> update_certificates.py
        echo '                    results[hash_value]["reason"] = cert_info.get("reason", "")' >> update_certificates.py
        echo '                    results[hash_value]["details"] = cert_info.get("details", "")' >> update_certificates.py
        echo '                else:' >> update_certificates.py
        echo '                    # Add new entry from PowerShell validation' >> update_certificates.py
        echo '                    results[hash_value] = {' >> update_certificates.py
        echo '                        "status": cert_info["status"],' >> update_certificates.py
        echo '                        "hvci_status": "Unknown",' >> update_certificates.py
        echo '                        "reason": cert_info.get("reason", ""),' >> update_certificates.py
        echo '                        "details": cert_info.get("details", "")' >> update_certificates.py
        echo '                    }' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '            print(f"Loaded {len(cert_results)} certificate validation results from PowerShell")' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '    except FileNotFoundError:' >> update_certificates.py
        echo '        print("PowerShell certificate validation results not found, using HVCI results only")' >> update_certificates.py
        echo '    except Exception as e:' >> update_certificates.py
        echo '        print(f"Error loading PowerShell results: {e}")' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    return results' >> update_certificates.py
        echo '' >> update_certificates.py
        echo 'def update_driver_data(analysis_results):' >> update_certificates.py
        echo '    """Update driver data with certificate attributes"""' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Load driver data' >> update_certificates.py
        echo '    drv_path = Path("data/drv.json")' >> update_certificates.py
        echo '    if not drv_path.exists():' >> update_certificates.py
        echo '        drv_path = Path("data/drvj.json")' >> update_certificates.py
        echo '        ' >> update_certificates.py
        echo '    with open(drv_path, "r") as f:' >> update_certificates.py
        echo '        drivers = json.load(f)' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    updated_count = 0' >> update_certificates.py
        echo '    cleaned_count = 0' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    for driver in drivers:' >> update_certificates.py
        echo '        if not driver.get("KnownVulnerableSamples"):' >> update_certificates.py
        echo '            continue' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '        for sample in driver["KnownVulnerableSamples"]:' >> update_certificates.py
        echo '            # Clean up obsolete fields' >> update_certificates.py
        echo '            obsolete_fields = ["HVCIStatus", "CertificateValid", "CertificateExpired", "CertificateRevoked", "CertificateSuspicious"]' >> update_certificates.py
        echo '            for field in obsolete_fields:' >> update_certificates.py
        echo '                if field in sample:' >> update_certificates.py
        echo '                    del sample[field]' >> update_certificates.py
        echo '                    cleaned_count += 1' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '            # Find matching analysis result' >> update_certificates.py
        echo '            result = None' >> update_certificates.py
        echo '            for hash_field in ["MD5", "SHA1", "SHA256"]:' >> update_certificates.py
        echo '                hash_value = sample.get(hash_field)' >> update_certificates.py
        echo '                if hash_value and hash_value.upper() in analysis_results:' >> update_certificates.py
        echo '                    result = analysis_results[hash_value.upper()]' >> update_certificates.py
        echo '                    break' >> update_certificates.py
        echo '            ' >> update_certificates.py
        echo '            if result:' >> update_certificates.py
        echo '                # Add certificate status from PowerShell validation or HVCI analysis' >> update_certificates.py
        echo '                cert_status = result["status"]' >> update_certificates.py
        echo '                ' >> update_certificates.py
        echo '                # Apply additional validation logic' >> update_certificates.py
        echo '                if cert_status == "Unknown" and sample.get("Signatures"):' >> update_certificates.py
        echo '                    # If PowerShell couldn\'t determine but we have signature data' >> update_certificates.py
        echo '                    cert_status = "Valid"' >> update_certificates.py
        echo '                ' >> update_certificates.py
        echo '                sample["CertificateStatus"] = cert_status' >> update_certificates.py
        echo '                ' >> update_certificates.py
        echo '                # Update existing LoadsDespiteHVCI field based on HVCI status' >> update_certificates.py
        echo '                hvci_status = result.get("hvci_status", "Unknown")' >> update_certificates.py
        echo '                if hvci_status == "Blocked":' >> update_certificates.py
        echo '                    sample["LoadsDespiteHVCI"] = "FALSE"' >> update_certificates.py
        echo '                elif hvci_status == "Allowed":' >> update_certificates.py
        echo '                    sample["LoadsDespiteHVCI"] = "TRUE"' >> update_certificates.py
        echo '                # If hvci_status is Unknown, preserve existing LoadsDespiteHVCI value' >> update_certificates.py
        echo '                    ' >> update_certificates.py
        echo '                updated_count += 1' >> update_certificates.py
        echo '            else:' >> update_certificates.py
        echo '                # No validation result found, try to infer from existing data' >> update_certificates.py
        echo '                if sample.get("Signatures") and len(sample["Signatures"]) > 0:' >> update_certificates.py
        echo '                    # Has signature data but no validation result' >> update_certificates.py
        echo '                    sample["CertificateStatus"] = "Unknown"' >> update_certificates.py
        echo '                elif not sample.get("CertificateStatus"):' >> update_certificates.py
        echo '                    # No signature data and no existing status' >> update_certificates.py
        echo '                    sample["CertificateStatus"] = "Unknown"' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Save updated data' >> update_certificates.py
        echo '    with open(drv_path, "w") as f:' >> update_certificates.py
        echo '        json.dump(drivers, f, indent=2)' >> update_certificates.py
        echo '        ' >> update_certificates.py
        echo '    print(f"Updated {updated_count} driver samples with certificate attributes")' >> update_certificates.py
        echo '    print(f"Cleaned {cleaned_count} obsolete fields")' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Generate certificate statistics' >> update_certificates.py
        echo '    cert_stats = {}' >> update_certificates.py
        echo '    for driver in drivers:' >> update_certificates.py
        echo '        if not driver.get("KnownVulnerableSamples"):' >> update_certificates.py
        echo '            continue' >> update_certificates.py
        echo '        for sample in driver["KnownVulnerableSamples"]:' >> update_certificates.py
        echo '            status = sample.get("CertificateStatus", "Unknown")' >> update_certificates.py
        echo '            cert_stats[status] = cert_stats.get(status, 0) + 1' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    print(f"Certificate Status Distribution:")' >> update_certificates.py
        echo '    for status, count in sorted(cert_stats.items()):' >> update_certificates.py
        echo '        print(f"  {status}: {count}")' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    return updated_count, cert_stats' >> update_certificates.py
        echo '' >> update_certificates.py
        echo 'def main():' >> update_certificates.py
        echo '    print("Loading analysis results...")' >> update_certificates.py
        echo '    analysis_results = load_analysis_results()' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    print("Updating driver database...")' >> update_certificates.py
        echo '    updated_count, cert_stats = update_driver_data(analysis_results)' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    print(f"Certificate update complete: {updated_count} samples updated")' >> update_certificates.py
        echo '    ' >> update_certificates.py
        echo '    # Save certificate statistics for summary' >> update_certificates.py
        echo '    with open("certificate_stats.json", "w") as f:' >> update_certificates.py
        echo '        json.dump({' >> update_certificates.py
        echo '            "updated_count": updated_count,' >> update_certificates.py
        echo '            "certificate_distribution": cert_stats,' >> update_certificates.py
        echo '            "total_analysis_results": len(analysis_results)' >> update_certificates.py
        echo '        }, f, indent=2)' >> update_certificates.py
        echo '' >> update_certificates.py
        echo 'if __name__ == "__main__":' >> update_certificates.py
        echo '    main()' >> update_certificates.py
        
        python update_certificates.py
        
    - name: Cleanup downloaded drivers (optional space saving)
      shell: powershell
      run: |
        $driversDir = "data/drivers"
        if (Test-Path $driversDir) {
          $fileCount = (Get-ChildItem $driversDir -File).Count
          $totalSize = [math]::Round((Get-ChildItem $driversDir -File | Measure-Object -Property Length -Sum).Sum / 1MB, 2)
          Write-Host "Cleaning up $fileCount driver files ($totalSize MB)..." -ForegroundColor Yellow
          Remove-Item $driversDir -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "Cleanup completed." -ForegroundColor Green
        }
        
    - name: Upload updated driver data and validation results
      uses: actions/upload-artifact@v4
      with:
        name: updated-drv-json
        path: |
          data/drv.json
          certificate_validation_results.json
          certificate_stats.json

  commit_changes:
    runs-on: ubuntu-latest
    needs: [download_blocklist, update_certificates]
    if: needs.download_blocklist.outputs.hash_changed == 'true'
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Download blocklist and hash
      uses: actions/download-artifact@v4
      with:
        name: blocklist
        
    - name: Download updated driver data
      uses: actions/download-artifact@v4
      with:
        name: updated-drv-json
        path: data/
        
    - name: Restore hash file
      run: |
        # The hash file comes from the blocklist artifact
        if [ -f "data/blocklist-hash.txt" ]; then
          echo "Hash file found in artifact"
          cat data/blocklist-hash.txt
        else
          echo "ERROR: Hash file not found in artifact"
          exit 1
        fi
        
    - name: Display Certificate Statistics
      shell: pwsh
      run: |
        if (Test-Path "certificate_stats.json") {
          $stats = Get-Content "certificate_stats.json" | ConvertFrom-Json
          Write-Host "=== Certificate Analysis Summary ===" -ForegroundColor Green
          Write-Host "Total Analysis Results: $($stats.total_analysis_results)" -ForegroundColor Cyan
          Write-Host "Updated Samples: $($stats.updated_count)" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "Certificate Distribution:" -ForegroundColor Yellow
          $stats.certificate_distribution.PSObject.Properties | ForEach-Object {
            Write-Host "  $($_.Name): $($_.Value)" -ForegroundColor White
          }
        }
        
        if (Test-Path "certificate_validation_results.json") {
          $validation = Get-Content "certificate_validation_results.json" | ConvertFrom-Json
          $downloadStats = $validation.download_statistics
          Write-Host ""
          Write-Host "=== Download Statistics ===" -ForegroundColor Green
          Write-Host "Download Attempts: $($downloadStats.attempted)" -ForegroundColor Cyan
          Write-Host "Successful Downloads: $($downloadStats.successful)" -ForegroundColor Green
          Write-Host "Failed Downloads: $($downloadStats.failed)" -ForegroundColor Red
          Write-Host "Skipped (No MD5): $($downloadStats.skipped)" -ForegroundColor Yellow
          
          if ($downloadStats.attempted -gt 0) {
            $successRate = [math]::Round(($downloadStats.successful / $downloadStats.attempted) * 100, 1)
            Write-Host "Success Rate: $successRate%" -ForegroundColor Cyan
          }
        }
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add files
        git add data/drv.json data/blocklist-hash.txt
        
        # Check if there are changes
        if git diff --staged --quiet; then
          echo "No changes to commit"
          exit 0
        fi
        
        # Commit changes
        git commit -m "ðŸ”’ Update HVCI and certificate validation data
        
        - Updated certificate validation attributes
        - Updated HVCI blocklist hash
        - Source: Microsoft Official Vulnerable Driver Blocklist
        - Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        git push
        echo "Changes committed and pushed successfully"

  create_summary:
    runs-on: ubuntu-latest
    needs: [analyze_hvci, commit_changes]
    if: always() && needs.analyze_hvci.result == 'success'
    steps:
    - name: Download analysis results
      uses: actions/download-artifact@v4
      with:
        name: hvci-analysis
        
    - name: Create workflow summary
      run: |
        if [ -f "hvci_summary.json" ]; then
          python3 << 'EOF'
        import json
        
        with open('hvci_summary.json', 'r') as f:
            summary = json.load(f)
        
        print("## ðŸ”’ HVCI Analysis Results")
        print("")
        print(f"**Total Drivers Analyzed:** {summary['total_drivers']:,}")
        print(f"**Blocked by HVCI:** {summary['blocked_drivers']:,}")
        print(f"**Allowed by HVCI:** {summary['allowed_drivers']:,}")
        print(f"**Block Rate:** {(summary['blocked_drivers']/summary['total_drivers']*100):.1f}%")
        print("")
        print("### Policy Components")
        components = summary['policy_components']
        print(f"- **Blocked Hashes:** {components['blocked_hashes']:,}")
        print(f"- **Blocked Signers:** {components['blocked_signers']:,}")
        print(f"- **Blocked Filenames:** {components['blocked_filenames']:,}")
        print("")
        print("*Source: Microsoft Official Vulnerable Driver Blocklist*")
        EOF
        else
          echo "## âš ï¸ Analysis Summary Not Available"
          echo "The HVCI analysis may have failed or been skipped."
        fi >> $GITHUB_STEP_SUMMARY
