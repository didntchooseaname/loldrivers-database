name: "HVCI Tag Update"

on:
  workflow_dispatch: # Allow manual trigger
  workflow_run:
    workflows: ["Update LOLDrivers Data"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  actions: read

jobs:
  check_prerequisites:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check_commits.outputs.should_run }}
    steps:
    - name: Check Prerequisites
      id: check_commits
      run: |
        echo "Checking prerequisites for HVCI Tag Update..."
        echo "Event name: ${{ github.event_name }}"
        
        # For manual or scheduled triggers, always allow the workflow to run
        if [ "${{ github.event_name }}" != "workflow_run" ]; then
          echo "Manual or scheduled trigger - workflow should run"
          echo "should_run=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
        echo "Workflow run event: ${{ github.event.workflow_run.event }}"
        
        # Check if the workflow_run was successful
        if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
          echo "Previous workflow did not complete successfully"
          echo "should_run=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Previous workflow completed successfully"
        
        # Check if there were recent commits to data files (indicating the workflow made changes)
        # We'll check the last few commits to see if any modified the data files
        curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/commits?per_page=5" > recent_commits.json
        
        # Check if any recent commits modified data/drvj.json or data/drv.json
        data_updated=$(cat recent_commits.json | jq -r '.[].files[]? | select(.filename == "data/drvj.json" or .filename == "data/drv.json") | .filename' | head -1)
        
        if [ -n "$data_updated" ]; then
          echo "Data file updates detected in recent commits"
          echo "Updated file: $data_updated"
          echo "should_run=true" >> $GITHUB_OUTPUT
        else
          echo "No data file updates detected in recent commits"
          echo "should_run=false" >> $GITHUB_OUTPUT
        fi

    - name: Summary
      run: |
        echo "## HVCI Workflow Prerequisites Check" >> $GITHUB_STEP_SUMMARY
        echo "**Event Type:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "**Previous Workflow:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Workflow Status:** ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "**Decision:** ${{ steps.check_commits.outputs.should_run }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.check_commits.outputs.should_run }}" = "true" ]; then
          echo "**Result:** HVCI workflow will proceed" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Result:** HVCI workflow will be skipped" >> $GITHUB_STEP_SUMMARY
        fi

  run_powershell:
    runs-on: windows-latest
    needs: [check_prerequisites]
    # Run based on the prerequisite check result
    if: needs.check_prerequisites.outputs.should_run == 'true'
    steps:
    - name: Workflow Status Info
      run: |
        Write-Host "=========================================="
        Write-Host "       HVCI TAG UPDATE WORKFLOW"
        Write-Host "=========================================="
        Write-Host "Trigger Event: ${{ github.event_name }}"
        if ("${{ github.event_name }}" -eq "workflow_run") {
          Write-Host "Previous Workflow: ${{ github.event.workflow_run.name }}"
          Write-Host "Previous Status: ${{ github.event.workflow_run.conclusion }}"
          Write-Host "Reason: Data file changes detected in recent commits"
        } elseif ("${{ github.event_name }}" -eq "workflow_dispatch") {
          Write-Host "Reason: Manual trigger"
        } elseif ("${{ github.event_name }}" -eq "schedule") {
          Write-Host "Reason: Scheduled run (weekly)"
        }
        Write-Host "=========================================="
        
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    - name: Run PowerShell script
      run: |
        # Download Microsoft's official HVCI blocklist
        Write-Host "Downloading Microsoft HVCI Vulnerable Driver Blocklist..."
        Invoke-WebRequest -Uri "https://aka.ms/VulnerableDriverBlockList" -OutFile "VulnerableDriverBlockList.zip"
        
        # Extract the zip file
        Write-Host "Extracting blocklist ZIP file..."
        Expand-Archive -Path "VulnerableDriverBlockList.zip" -DestinationPath "blocklist" -Force
        
        # Find XML files in the extracted content
        $xmlFiles = Get-ChildItem -Path "blocklist" -Filter "*.xml" -Recurse
        Write-Host "Found $($xmlFiles.Count) XML file(s):"
        $xmlFiles | ForEach-Object { Write-Host "  - $($_.FullName)" }
        
        # Look specifically for SiPolicy_Enforced_Server2016.xml in VulnerableDriverBlockList folder
        $targetXmlFile = Get-ChildItem -Path "blocklist" -Filter "SiPolicy_Enforced_Server2016.xml" -Recurse | Select-Object -First 1
        
        if (-not $targetXmlFile) {
            Write-Host "SiPolicy_Enforced_Server2016.xml not found, looking for any XML file in VulnerableDriverBlockList folder..."
            $targetXmlFile = Get-ChildItem -Path "blocklist\VulnerableDriverBlockList" -Filter "*.xml" -ErrorAction SilentlyContinue | Select-Object -First 1
        }
        
        if (-not $targetXmlFile) {
            Write-Error "No SiPolicy_Enforced_Server2016.xml or other XML files found in VulnerableDriverBlockList folder"
            exit 1
        }
        
        $xmlFile = $targetXmlFile.FullName
        Write-Host "Using XML file: $xmlFile"
        
        # Parse the XML HVCI policy (following Trail of Bits logic)
        Write-Host "Parsing XML HVCI policy..."
        [xml]$policy = Get-Content -Path $xmlFile -Raw
        
        # Extract policy components following Trail of Bits approach
        $fileRules = $policy.SiPolicy.FileRules
        $signers = $policy.SiPolicy.Signers.Signer
        
        Write-Host "Found file rules: $($fileRules.ChildNodes.Count)"
        Write-Host "Found signers: $($signers.Count)"
        
        # Initialize collections for policy analysis
        $blockedHashes = @{}
        $blockedSigners = @{}
        $blockedVersions = @{}
        $blockedFilenames = @{}
        
        # Extract blocked hashes from Deny rules - ONLY Hash attribute values
        if ($fileRules.Deny) {
            Write-Host "Processing Deny rules..."
            
            # Debug: Show first few Deny rules to verify structure
            $sampleDenyRules = $fileRules.Deny | Select-Object -First 3
            Write-Host "Sample Deny rules (first 3):"
            foreach ($rule in $sampleDenyRules) {
                Write-Host "  ID: $($rule.ID)"
                Write-Host "  FriendlyName: $($rule.FriendlyName)"
                Write-Host "  Hash attribute ONLY: $($rule.Hash)"
                Write-Host "  FileName: $($rule.FileName)"
                Write-Host "  ---"
            }
            
            foreach ($denyRule in $fileRules.Deny) {
                # Extract ONLY the Hash attribute value, completely ignore FriendlyName
                if ($denyRule.Hash -and $denyRule.Hash -is [string]) {
                    $rawHashValue = $denyRule.Hash.Trim()
                    
                    # Clean hash: remove any non-hexadecimal characters and convert to uppercase
                    $cleanHashValue = ($rawHashValue -replace '[^A-F0-9]', '').ToUpper()
                    
                    # Validate hash length and store
                    if ($cleanHashValue.Length -eq 32) {
                        $blockedHashes[$cleanHashValue] = "MD5"
                        Write-Host "  Added MD5 hash: $cleanHashValue"
                    } elseif ($cleanHashValue.Length -eq 40) {
                        $blockedHashes[$cleanHashValue] = "SHA1" 
                        Write-Host "  Added SHA1 hash: $cleanHashValue"
                    } elseif ($cleanHashValue.Length -eq 64) {
                        $blockedHashes[$cleanHashValue] = "SHA256"
                        Write-Host "  Added SHA256 hash: $cleanHashValue"
                    } else {
                        Write-Host "  Skipped invalid hash length ($($cleanHashValue.Length)): $cleanHashValue"
                    }
                }
                
                # Extract filename restrictions (separate from hash processing)
                if ($denyRule.FileName) {
                    $blockedFilenames[$denyRule.FileName] = $denyRule.MaximumFileVersion
                    if ($denyRule.MaximumFileVersion) {
                        $blockedVersions[$denyRule.FileName] = $denyRule.MaximumFileVersion
                    }
                }
            }
        }
        
        # Extract blocked signers/certificates
        if ($signers) {
            foreach ($signer in $signers) {
                if ($signer.CertRoot -and $signer.CertRoot.Value) {
                    $tbsHash = $signer.CertRoot.Value.ToLower()
                    $blockedSigners[$tbsHash] = @{
                        Name = $signer.Name
                        FileAttribRef = $signer.FileAttribRef
                    }
                }
            }
        }
        
        # Create helper functions following Trail of Bits logic
        function Test-BlockedHash($driver) {
            $driverHashes = @(
                $driver.MD5,
                $driver.SHA1, 
                $driver.SHA256,
                $driver.Authentihash.MD5,
                $driver.Authentihash.SHA1,
                $driver.Authentihash.SHA256
            ) | Where-Object { $_ -and $_.Length -ge 32 }
            
            foreach ($hash in $driverHashes) {
                $cleanHash = $hash.Trim().ToUpper() -replace '[^A-F0-9]', ''
                if ($blockedHashes.ContainsKey($cleanHash)) {
                    return @{
                        IsBlocked = $true
                        MatchedHash = $cleanHash
                        HashType = $blockedHashes[$cleanHash]
                        Reason = "Hash blocked"
                    }
                }
            }
            return @{ IsBlocked = $false }
        }
        
        function Test-BlockedFilename($driver) {
            # Check if any Tags match a blocked FileName and if version is in blocked range
            if (-not $driver.Tags -or -not ($driver.Tags -is [array])) {
                return @{ IsBlocked = $false }
            }
            
            $fileVersion = $driver.FileVersion
            foreach ($tag in $driver.Tags) {
                if ($tag -and $blockedFilenames.ContainsKey($tag)) {
                    # Find corresponding Deny rule to extract version bounds
                    $denyRule = $fileRules.Deny | Where-Object { $_.FileName -eq $tag } | Select-Object -First 1
                    $minVersion = $null
                    $maxVersion = $null
                    
                    if ($denyRule) {
                        if ($denyRule.MinimumFileVersion) { $minVersion = $denyRule.MinimumFileVersion }
                        if ($denyRule.MaximumFileVersion) { $maxVersion = $denyRule.MaximumFileVersion }
                    }
                    
                    # If no version restriction in rule, use stored value
                    if (-not $maxVersion -and $blockedVersions.ContainsKey($tag)) {
                        $maxVersion = $blockedVersions[$tag]
                    }
                    if (-not $maxVersion -and $blockedFilenames[$tag]) {
                        $maxVersion = $blockedFilenames[$tag]
                    }
                    
                    if ($fileVersion -and ($minVersion -or $maxVersion)) {
                        try {
                            # Clean and parse version
                            $ver = ($fileVersion -replace ',\s*', '.').Split(' ')[0]
                            $verObj = [version]$ver
                            $minOk = $true
                            $maxOk = $true
                            
                            # Check version bounds
                            if ($minVersion) { $minOk = ($verObj -ge [version]$minVersion) }
                            if ($maxVersion) { $maxOk = ($verObj -le [version]$maxVersion) }
                            
                            if ($minOk -and $maxOk) {
                                return @{
                                    IsBlocked = $true
                                    MatchedFilename = $tag
                                    DriverVersion = $ver
                                    MinVersion = $minVersion
                                    MaxVersion = $maxVersion
                                    Reason = "Filename and version blocked"
                                }
                            }
                        } catch {
                            Write-Host "  Warning: Failed to parse version '$fileVersion' for tag '$tag'"
                        }
                    } elseif ($fileVersion -and ($fileVersion -eq $minVersion -or $fileVersion -eq $maxVersion)) {
                        # Exact version match
                        return @{
                            IsBlocked = $true
                            MatchedFilename = $tag
                            DriverVersion = $fileVersion
                            ExactMatch = $true
                            Reason = "Filename and version blocked (exact match)"
                        }
                    } elseif (-not $minVersion -and -not $maxVersion) {
                        # Pas de restriction de version, le filename seul suffit
                        return @{
                            IsBlocked = $true
                            MatchedFilename = $tag
                            Reason = "Filename blocked (no version restriction)"
                        }
                    }
                }
            }
            return @{ IsBlocked = $false }
        }
        
        function Test-BlockedSigner($driver) {
            if (-not $driver.Signatures -or -not $driver.Signatures.Certificates) {
                return @{ IsBlocked = $false }
            }
            
            # Get file attribute for this filename
            $fileAttrib = $fileRules.FileAttrib | Where-Object { $_.FileName -eq $driver.OriginalFilename }
            
            foreach ($cert in $driver.Signatures.Certificates) {
                $certHashes = @(
                    $cert.TBS.MD5,
                    $cert.TBS.SHA1,
                    $cert.TBS.SHA256,
                    $cert.TBS.SHA384
                ) | Where-Object { $_ } | ForEach-Object { $_.ToLower() }
                
                foreach ($certHash in $certHashes) {
                    if ($blockedSigners.ContainsKey($certHash)) {
                        $signer = $blockedSigners[$certHash]
                        $blockedFiles = $signer.FileAttribRef
                        
                        # If no specific file restrictions or this file is in the blocked list
                        if (-not $blockedFiles -or ($blockedFiles.RuleID -contains $fileAttrib.ID)) {
                            return @{
                                IsBlocked = $true
                                MatchedCert = $certHash
                                SignerName = $signer.Name
                                Reason = "Certificate blocked"
                            }
                        }
                    }
                }
            }
            return @{ IsBlocked = $false }
        }
        
        function Test-BlockedVersion($driver) {
            if (-not $driver.OriginalFilename -or -not $driver.FileVersion) {
                return @{ IsBlocked = $false }
            }
            
            $maxVersion = $blockedVersions[$driver.OriginalFilename]
            if ($maxVersion) {
                try {
                    # Clean and parse version string
                    $driverVersion = ($driver.FileVersion -replace ',\s*', '.').Split(' ')[0]
                    if ([version]$driverVersion -le [version]$maxVersion) {
                        return @{
                            IsBlocked = $true
                            MaxVersion = $maxVersion
                            DriverVersion = $driverVersion
                            Reason = "Version blocked"
                        }
                    }
                } catch {
                    # Version parsing failed, skip version check
                }
            }
            return @{ IsBlocked = $false }
        }
        
        Write-Host "Extracted HVCI policy components:"
        Write-Host "  - Blocked hashes: $($blockedHashes.Count)"
        Write-Host "  - Blocked signers: $($blockedSigners.Count)"  
        Write-Host "  - Version restrictions: $($blockedVersions.Count)"
        Write-Host "  - Filename restrictions: $($blockedFilenames.Count)"
        
        # Load local LOLDrivers data from the repository
        Write-Host "Loading local LOLDrivers data from repository..."
        
        # Check if we're in a git repository and load the local file
        $localJsonPath = "data\drv.json"
        if (-not (Test-Path $localJsonPath)) {
            $localJsonPath = "data\drvj.json"  # Try alternative name
        }
        
        if (-not (Test-Path $localJsonPath)) {
            Write-Error "Could not find local drv.json or drvj.json file in data folder"
            exit 1
        }
        
        Write-Host "Loading drivers from: $localJsonPath"
        $loldrivers = Get-Content -Path $localJsonPath -Raw | ConvertFrom-Json -AsHashTable
        
        if (-not $loldrivers) {
            Write-Error "Could not load LOLDrivers data from local file"
            exit 1
        }
        
        Write-Host "Processing $($loldrivers.Count) drivers from local LOLDrivers database..."
        
        # Analyze drivers using comprehensive HVCI logic (following Trail of Bits approach)
        $totalDrivers = 0
        $blockedCount = 0
        $allowedCount = 0
        $blockedDrivers = @()
        $allowedDrivers = @()
        
        foreach ($driver in $loldrivers) {
            if ($driver.KnownVulnerableSamples) {
                foreach ($sample in $driver.KnownVulnerableSamples) {
                    $totalDrivers++
                    
                    # Test all HVCI blocking conditions following Trail of Bits logic
                    $hashResult = Test-BlockedHash $sample
                    $filenameResult = Test-BlockedFilename $sample
                    $signerResult = Test-BlockedSigner $sample  
                    $versionResult = Test-BlockedVersion $sample
                    
                    $isBlocked = $false
                    $blockReason = "Allowed by HVCI policy"
                    $matchedDetail = "N/A"
                    $matchedType = "N/A"
                    
                    # Check blocking conditions in priority order (hash > filename+version > version > signer)
                    if ($hashResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $hashResult.Reason
                        $matchedDetail = $hashResult.MatchedHash
                        $matchedType = $hashResult.HashType
                    }
                    elseif ($filenameResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $filenameResult.Reason
                        if ($filenameResult.ExactMatch) {
                            $matchedDetail = "Tag: '$($filenameResult.MatchedFilename)' Version: $($filenameResult.DriverVersion) (exact match)"
                        } elseif ($filenameResult.MinVersion -or $filenameResult.MaxVersion) {
                            $versionRange = ""
                            if ($filenameResult.MinVersion) { $versionRange += "Min: $($filenameResult.MinVersion) " }
                            if ($filenameResult.MaxVersion) { $versionRange += "Max: $($filenameResult.MaxVersion)" }
                            $matchedDetail = "Tag: '$($filenameResult.MatchedFilename)' Version: $($filenameResult.DriverVersion) ($versionRange)"
                        } else {
                            $matchedDetail = "Tag: '$($filenameResult.MatchedFilename)' (no version restriction)"
                        }
                        $matchedType = "Filename"
                    }
                    elseif ($versionResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $versionResult.Reason
                        $matchedDetail = "$($versionResult.DriverVersion) <= $($versionResult.MaxVersion)"
                        $matchedType = "Version"
                    }
                    elseif ($signerResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $signerResult.Reason
                        $matchedDetail = $signerResult.MatchedCert
                        $matchedType = "Certificate"
                    }
                    
                    # Create comprehensive driver result object
                    $driverResult = [PSCustomObject]@{
                        MD5 = $sample.MD5 -or "N/A"
                        SHA1 = $sample.SHA1 -or "N/A"
                        SHA256 = $sample.SHA256 -or "N/A"
                        AuthentiMD5 = if ($sample.Authentihash -and $sample.Authentihash.MD5) { $sample.Authentihash.MD5 } else { "N/A" }
                        AuthentiSHA1 = if ($sample.Authentihash -and $sample.Authentihash.SHA1) { $sample.Authentihash.SHA1 } else { "N/A" }
                        AuthentiSHA256 = if ($sample.Authentihash -and $sample.Authentihash.SHA256) { $sample.Authentihash.SHA256 } else { "N/A" }
                        Status = if ($isBlocked) { "Blocked" } else { "Allowed" }
                        BlockReason = $blockReason
                        MatchedDetail = $matchedDetail
                        MatchedType = $matchedType
                        DriverId = $driver.Id
                        Company = $sample.Company -or "Unknown"
                        Filename = $sample.Filename -or $sample.OriginalFilename -or "Unknown"
                        OriginalFilename = $sample.OriginalFilename -or "Unknown"
                        FileVersion = $sample.FileVersion -or "Unknown"
                        Description = $sample.Description -or "Unknown"
                    }
                    
                    if ($isBlocked) {
                        $blockedDrivers += $driverResult
                        $blockedCount++
                    } else {
                        $allowedDrivers += $driverResult
                        $allowedCount++
                    }
                }
            }
        }
        
        # Output comprehensive analysis summary
        Write-Host "=========================================="
        Write-Host "        COMPREHENSIVE HVCI ANALYSIS"
        Write-Host "=========================================="
        Write-Host "Total drivers analyzed: $totalDrivers"
        Write-Host "Blocked drivers (blocked by HVCI): $blockedCount"
        Write-Host "Allowed drivers (can load with HVCI): $allowedCount"
        Write-Host ""
        Write-Host "HVCI Policy Components Found:"
        Write-Host "  - Blocked hashes: $($blockedHashes.Count)"
        Write-Host "  - Blocked signers/certificates: $($blockedSigners.Count)"  
        Write-Host "  - Version restrictions: $($blockedVersions.Count)"
        Write-Host "  - Filename restrictions: $($blockedFilenames.Count)"
        Write-Host "=========================================="
        
        # Create comprehensive CSV with all analysis information
        $csvContent = "MD5,SHA1,SHA256,AuthentiMD5,AuthentiSHA1,AuthentiSHA256,Status,BlockReason,MatchedDetail,MatchedType,DriverId,Company,Filename,OriginalFilename,FileVersion,Description`n"
        
        foreach ($driver in $blockedDrivers) {
            $csvContent += "`"$($driver.MD5)`",`"$($driver.SHA1)`",`"$($driver.SHA256)`",`"$($driver.AuthentiMD5)`",`"$($driver.AuthentiSHA1)`",`"$($driver.AuthentiSHA256)`",`"$($driver.Status)`",`"$($driver.BlockReason)`",`"$($driver.MatchedDetail)`",`"$($driver.MatchedType)`",`"$($driver.DriverId)`",`"$($driver.Company)`",`"$($driver.Filename)`",`"$($driver.OriginalFilename)`",`"$($driver.FileVersion)`",`"$($driver.Description)`"`n"
        }
        
        foreach ($driver in $allowedDrivers) {
            $csvContent += "`"$($driver.MD5)`",`"$($driver.SHA1)`",`"$($driver.SHA256)`",`"$($driver.AuthentiMD5)`",`"$($driver.AuthentiSHA1)`",`"$($driver.AuthentiSHA256)`",`"$($driver.Status)`",`"$($driver.BlockReason)`",`"$($driver.MatchedDetail)`",`"$($driver.MatchedType)`",`"$($driver.DriverId)`",`"$($driver.Company)`",`"$($driver.Filename)`",`"$($driver.OriginalFilename)`",`"$($driver.FileVersion)`",`"$($driver.Description)`"`n"
        }
        
        # Write CSV file
        $csvContent | Out-File -FilePath "hvci_drivers.csv" -Encoding UTF8
        
        # Create detailed analysis summary with breakdown by blocking reason
        $hashBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -like "*Hash*" }).Count
        $filenameBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -eq "Filename" }).Count
        $certBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -eq "Certificate" }).Count
        $versionBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -eq "Version" }).Count
        
        $summaryContent = @"
        # Comprehensive HVCI Blocklist Analysis Summary
        
        ## Analysis Details
        - **Source**: Microsoft Official Vulnerable Driver Blocklist (following Trail of Bits methodology)
        - **Blocklist URL**: https://aka.ms/VulnerableDriverBlockList
        - **Analysis Date**: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")
        - **XML File**: SiPolicy_Enforced_Server2016.xml
        - **Local Data Source**: $localJsonPath
        - **Analysis Method**: Comprehensive HVCI policy parsing (hash, certificate, version, filename rules)
        
        ## Results Summary
        - **Total Drivers Analyzed**: $totalDrivers
        - **Blocked Drivers**: $blockedCount
        - **Allowed Drivers**: $allowedCount
        - **Blocked Percentage**: $([math]::Round(($blockedCount / $totalDrivers) * 100, 2))%
        
        ## Blocking Reasons Breakdown
        - **Hash-based blocks**: $hashBlocked drivers
        - **Filename/Tag-based blocks**: $filenameBlocked drivers
        - **Certificate-based blocks**: $certBlocked drivers  
        - **Version-based blocks**: $versionBlocked drivers
        
        ## HVCI Policy Components Analyzed
        - **Blocked Hashes**: $($blockedHashes.Count) (MD5, SHA1, SHA256, Authentihash)
        - **Blocked Filenames**: $($blockedFilenames.Count) (FileName rules with version checks)
        - **Blocked Signers**: $($blockedSigners.Count) (Certificate TBS hashes)
        - **Version Restrictions**: $($blockedVersions.Count) (MaximumFileVersion rules)
        
        ## Analysis Methodology
        This comprehensive analysis follows the Trail of Bits HVCI methodology which checks:
        1. **Hash Matching**: Compares driver hashes (MD5, SHA1, SHA256, Authentihash) against blocked hash lists
        2. **Filename/Tag Matching**: Case-sensitive comparison of driver Tags array against XML FileName entries with version validation
        3. **Certificate Validation**: Checks driver certificates against blocked signer TBS hashes
        4. **Version Checking**: Validates driver versions against maximum allowed versions
        
        The analysis uses the official Microsoft Vulnerable Driver Blocklist XML policy file which contains FileRule entries with Deny rules for various driver attributes.
        
        ## Hash Distribution in Blocklist
        "@
        
        # Add hash distribution statistics
        $hashStats = $blockedHashes.Values | Group-Object | Sort-Object Name
        foreach ($stat in $hashStats) {
            $summaryContent += "`n- **$($stat.Name)**: $($stat.Count) hashes"
        }
        
        # Add certificate distribution statistics
        if ($blockedSigners.Count -gt 0) {
            $summaryContent += "`n`n## Certificate/Signer Distribution"
            $summaryContent += "`n- **Total Blocked Signers**: $($blockedSigners.Count)"
        }
        
        # Add version restriction statistics  
        if ($blockedVersions.Count -gt 0) {
            $summaryContent += "`n`n## Version Restrictions"
            $summaryContent += "`n- **Files with Version Limits**: $($blockedVersions.Count)"
        }
        
        $summaryContent | Out-File -FilePath "hvci_analysis_summary.txt" -Encoding UTF8
        
        Write-Host "Comprehensive CSV file created: hvci_drivers.csv"
        Write-Host "Detailed summary file created: hvci_analysis_summary.txt"
        Write-Host ""
        Write-Host "Analysis complete! Found $blockedCount blocked and $allowedCount allowed drivers using comprehensive HVCI methodology."
        
    - name: Upload CSV
      uses: actions/upload-artifact@v4
      with:
        name: hvci_drivers
        path: |
          hvci_drivers.csv
          hvci_analysis_summary.txt

  run_node:
    needs: [run_powershell]
    runs-on: ubuntu-latest
    # Only run if PowerShell job succeeded (which already includes prerequisite checks)
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Download CSV
      uses: actions/download-artifact@v4
      with:
        name: hvci_drivers
        path: ./
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Create HVCI tagging script
      run: |
        cat > hvci-tagger.js << 'EOF'
        #!/usr/bin/env node
        
        import fs from 'fs';
        import { createReadStream } from 'fs';
        import { createInterface } from 'readline';
        
        const DRV_JSON_PATH = './data/drv.json';
        const FALLBACK_JSON_PATH = './data/drvj.json';
        const CSV_PATH = './hvci_drivers.csv';
        
        async function processCSV() {
            console.log('Reading HVCI CSV results...');
            
            const allowedHashes = new Set();
            const blockedHashes = new Set();
            const hashDetails = new Map(); // Store hash -> details mapping
            
            // Check if CSV exists and has content
            if (!fs.existsSync(CSV_PATH)) {
                console.log('No CSV file found, assuming no HVCI status available');
                return { allowedHashes, blockedHashes, hashDetails };
            }
            
            const fileStream = createReadStream(CSV_PATH);
            const rl = createInterface({
                input: fileStream,
                crlfDelay: Infinity
            });
            
            let lineNumber = 0;
            for await (const line of rl) {
                lineNumber++;
                if (lineNumber === 1) continue; // Skip header
                
                const columns = line.split(',');
                // New CSV format: MD5,SHA1,SHA256,AuthentiMD5,AuthentiSHA1,AuthentiSHA256,Status,BlockReason,MatchedDetail,MatchedType,DriverId,Company,Filename,OriginalFilename,FileVersion,Description
                if (columns.length >= 7) {
                    const md5 = columns[0]?.replace(/"/g, '').trim();
                    const sha1 = columns[1]?.replace(/"/g, '').trim();
                    const sha256 = columns[2]?.replace(/"/g, '').trim();
                    const authentiMD5 = columns[3]?.replace(/"/g, '').trim();
                    const authentiSHA1 = columns[4]?.replace(/"/g, '').trim();
                    const authentiSHA256 = columns[5]?.replace(/"/g, '').trim();
                    const status = columns[6]?.replace(/"/g, '').trim();
                    
                    // Collect all hashes (including Authentihash)
                    const hashes = [md5, sha1, sha256, authentiMD5, authentiSHA1, authentiSHA256].filter(hash => hash && hash !== 'N/A');
                    
                    hashes.forEach(hash => {
                        if (hash) {
                            const lowerHash = hash.toLowerCase();
                            hashDetails.set(lowerHash, {
                                md5, sha1, sha256, authentiMD5, authentiSHA1, authentiSHA256, status,
                                type: hash === md5 ? 'MD5' : 
                                      hash === sha1 ? 'SHA1' : 
                                      hash === sha256 ? 'SHA256' :
                                      hash === authentiMD5 ? 'AuthentiMD5' :
                                      hash === authentiSHA1 ? 'AuthentiSHA1' :
                                      hash === authentiSHA256 ? 'AuthentiSHA256' : 'Unknown'
                            });
                            
                            if (status === 'Allowed') {
                                allowedHashes.add(lowerHash);
                            } else if (status === 'Blocked') {
                                blockedHashes.add(lowerHash);
                            }
                        }
                    });
                }
            }
            
            console.log(`Found ${allowedHashes.size} allowed hashes and ${blockedHashes.size} blocked hashes from HVCI policy`);
            return { allowedHashes, blockedHashes, hashDetails };
        }
        
        function getDriverDisplayName(driver, sample) {
            // Get the best available name for the driver
            if (sample.Filename) return sample.Filename;
            if (sample.OriginalFilename) return sample.OriginalFilename;
            if (driver.Tags && driver.Tags.length > 0) {
                // Find a meaningful tag (not just HVCI tags)
                const meaningfulTag = driver.Tags.find(tag => 
                    !tag.includes('HVCI') && tag.length > 3
                );
                if (meaningfulTag) return meaningfulTag;
            }
            return 'Unknown Driver';
        }
        
        async function updateDriversJSON() {
            console.log('Loading drivers database...');
            
            let driversData;
            let sourceFile;
            try {
                driversData = JSON.parse(fs.readFileSync(DRV_JSON_PATH, 'utf8'));
                sourceFile = DRV_JSON_PATH;
                console.log(`Loaded drivers from ${DRV_JSON_PATH}`);
            } catch (error) {
                console.log(`Failed to load ${DRV_JSON_PATH}, trying fallback...`);
                try {
                    driversData = JSON.parse(fs.readFileSync(FALLBACK_JSON_PATH, 'utf8'));
                    sourceFile = FALLBACK_JSON_PATH;
                    console.log(`Loaded drivers from ${FALLBACK_JSON_PATH}`);
                } catch (fallbackError) {
                    console.error('Failed to load drivers data from both paths');
                    throw fallbackError;
                }
            }
            
            // Clean up any existing HVCI tags that might be present
            console.log('Cleaning up any existing HVCI tags...');
            let cleanupCount = 0;
            driversData.forEach(driver => {
                if (driver.Tags && Array.isArray(driver.Tags)) {
                    const originalLength = driver.Tags.length;
                    
                    // Remove any HVCI tags since we now use LoadsDespiteHVCI property
                    driver.Tags = driver.Tags.filter(tag => 
                        !tag.toLowerCase().includes('hvci')
                    );
                    
                    if (originalLength !== driver.Tags.length) {
                        cleanupCount++;
                        console.log(`Removed ${originalLength - driver.Tags.length} HVCI tags from driver ${driver.Id}`);
                    }
                }
            });
            
            console.log(`Cleaned up HVCI tags in ${cleanupCount} drivers (now using LoadsDespiteHVCI property)`);
            
            const { allowedHashes, blockedHashes, hashDetails } = await processCSV();
            
            let newlyPassedCount = 0;
            let newlyBlockedCount = 0;
            let newlyUnknownCount = 0;
            let totalHvciPassedCount = 0;
            let totalHvciBlockedCount = 0;
            let totalHvciUnknownCount = 0;
            
            const changes = {
                newlyPassed: [],
                newlyBlocked: [],
                newlyUnknown: [],
                summary: []
            };
            
            driversData.forEach(driver => {
                if (driver.KnownVulnerableSamples) {
                    driver.KnownVulnerableSamples.forEach(sample => {
                        const sampleHashes = [
                            sample.MD5?.toLowerCase(),
                            sample.SHA1?.toLowerCase(), 
                            sample.SHA256?.toLowerCase(),
                            sample.Authentihash?.MD5?.toLowerCase(),
                            sample.Authentihash?.SHA1?.toLowerCase(),
                            sample.Authentihash?.SHA256?.toLowerCase()
                        ].filter(Boolean);
                        
                        let isAllowed = false;
                        let isBlocked = false;
                        let matchedHash = null;
                        let matchedHashType = null;
                        
                        // Check if any hash is in the allowed or blocked lists
                        for (const hash of sampleHashes) {
                            if (allowedHashes.has(hash)) {
                                isAllowed = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                            if (blockedHashes.has(hash)) {
                                isBlocked = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                        }
                        
                        // HVCI LoadsDespiteHVCI logic:
                        // - If driver has Allowed status -> "LoadsDespiteHVCI": "TRUE"
                        // - If driver has Blocked status -> "LoadsDespiteHVCI": "FALSE"
                        // - If driver is not in CSV -> leave as is or set to null
                        
                        const currentLoadsDespiteHVCI = sample.LoadsDespiteHVCI;
                        let newLoadsDespiteHVCI = null;
                        
                        if (isAllowed) {
                            // Driver is allowed by HVCI policy
                            newLoadsDespiteHVCI = "TRUE";
                            if (currentLoadsDespiteHVCI !== "TRUE") {
                                newlyPassedCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                changes.newlyPassed.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: matchedHash.toUpperCase(),
                                    hashType: matchedHashType,
                                    company: sample.Company || 'Unknown',
                                    previousValue: currentLoadsDespiteHVCI || 'null',
                                    newValue: 'TRUE'
                                });
                            }
                            
                        } else if (isBlocked) {
                            // Driver is blocked by HVCI policy
                            newLoadsDespiteHVCI = "FALSE";
                            if (currentLoadsDespiteHVCI !== "FALSE") {
                                newlyBlockedCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                changes.newlyBlocked.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: matchedHash.toUpperCase(),
                                    hashType: matchedHashType,
                                    company: sample.Company || 'Unknown',
                                    previousValue: currentLoadsDespiteHVCI || 'null',
                                    newValue: 'FALSE'
                                });
                            }
                            
                        } else {
                            // Driver is not in CSV, leave LoadsDespiteHVCI as is
                            if (currentLoadsDespiteHVCI === undefined || currentLoadsDespiteHVCI === null) {
                                newlyUnknownCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                const firstHash = sampleHashes[0] || 'Unknown';
                                changes.newlyUnknown.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: firstHash.toUpperCase(),
                                    hashType: 'N/A',
                                    company: sample.Company || 'Unknown',
                                    previousValue: 'undefined',
                                    newValue: 'unchanged'
                                });
                            }
                        }
                        
                        // Update the LoadsDespiteHVCI property if needed
                        if (newLoadsDespiteHVCI !== null) {
                            sample.LoadsDespiteHVCI = newLoadsDespiteHVCI;
                        }
                        
                        // Count totals
                        if (sample.LoadsDespiteHVCI === "TRUE") {
                            totalHvciPassedCount++;
                        }
                        if (sample.LoadsDespiteHVCI === "FALSE") {
                            totalHvciBlockedCount++;
                        }
                        if (sample.LoadsDespiteHVCI === undefined || sample.LoadsDespiteHVCI === null) {
                            totalHvciUnknownCount++;
                        }
                    });
                }
            });
            
            // Add metadata
            if (!driversData._metadata) {
                driversData._metadata = {};
            }
            driversData._metadata.hvciCheck = {
                lastCheck: new Date().toISOString(),
                newlyAllowedDrivers: newlyPassedCount,
                newlyBlockedDrivers: newlyBlockedCount,
                newlyUnknownDrivers: newlyUnknownCount,
                totalLoadsTrue: totalHvciPassedCount,
                totalLoadsFalse: totalHvciBlockedCount,
                totalLoadsUnknown: totalHvciUnknownCount,
                source: 'Microsoft Official Vulnerable Driver Blocklist',
                sourceUrl: 'https://aka.ms/VulnerableDriverBlockList',
                method: 'LoadsDespiteHVCI property update via XML blocklist',
                triggerEvent: process.env.GITHUB_EVENT_NAME || 'manual'
            };
            
            // Create detailed summary
            let summaryContent = '# HVCI LoadsDespiteHVCI Update Summary\n\n';
            summaryContent += `**Date:** ${new Date().toISOString()}\n`;
            summaryContent += `**Trigger:** ${process.env.GITHUB_EVENT_NAME || 'manual'}\n`;
            summaryContent += `**Method:** Microsoft Official Vulnerable Driver Blocklist\n`;
            summaryContent += `**Blocklist Source:** https://aka.ms/VulnerableDriverBlockList\n`;
            summaryContent += `**Property Updated:** LoadsDespiteHVCI\n`;
            summaryContent += `**Newly Allowed Drivers:** ${newlyPassedCount}\n`;
            summaryContent += `**Newly Blocked Drivers:** ${newlyBlockedCount}\n`;
            summaryContent += `**Newly Unknown Drivers:** ${newlyUnknownCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = TRUE:** ${totalHvciPassedCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = FALSE:** ${totalHvciBlockedCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = null/undefined:** ${totalHvciUnknownCount}\n\n`;
            
            summaryContent += '## Analysis Method\n\n';
            summaryContent += 'This analysis uses the official Microsoft Vulnerable Driver Blocklist which:\n';
            summaryContent += '1. Downloads the official blocklist from https://aka.ms/VulnerableDriverBlockList\n';
            summaryContent += '2. Extracts XML files from the ZIP archive\n';
            summaryContent += '3. Parses XML FileRule entries to extract blocked driver hashes\n';
            summaryContent += '4. Compares LOLDrivers database against the blocklist\n';
            summaryContent += '5. Determines blocked/allowed status based on hash matches\n\n';
            summaryContent += '**LoadsDespiteHVCI Logic:**\n';
            summaryContent += '- Drivers **NOT** in Microsoft blocklist -> **LoadsDespiteHVCI = "TRUE"**\n';
            summaryContent += '- Drivers **IN** Microsoft blocklist -> **LoadsDespiteHVCI = "FALSE"**\n';
            summaryContent += '- Drivers with insufficient hash data -> **LoadsDespiteHVCI = unchanged**\n\n';
            
            if (changes.newlyBlocked.length > 0) {
                summaryContent += '## Newly Blocked Drivers (LoadsDespiteHVCI = FALSE)\n\n';
                summaryContent += '*These drivers are in the Microsoft blocklist and cannot load with HVCI:*\n\n';
                changes.newlyBlocked.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - Previous: ${item.previousValue} -> New: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyPassed.length > 0) {
                summaryContent += '## Newly Allowed Drivers (LoadsDespiteHVCI = TRUE)\n\n';
                summaryContent += '*These drivers are NOT in the Microsoft blocklist and can load with HVCI:*\n\n';
                changes.newlyPassed.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - Previous: ${item.previousValue} -> New: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyUnknown.length > 0) {
                summaryContent += '## Newly Detected Unknown Drivers\n\n';
                summaryContent += '*These drivers have insufficient hash data for blocklist comparison:*\n\n';
                changes.newlyUnknown.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - Status: Insufficient hash data for comparison\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - LoadsDespiteHVCI: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyPassed.length === 0 && changes.newlyBlocked.length === 0 && changes.newlyUnknown.length === 0) {
                summaryContent += '## No Changes\n\nNo LoadsDespiteHVCI properties were updated in this run.\n';
                summaryContent += 'All drivers already have current HVCI policy status.\n';
            }
            
            fs.writeFileSync('hvci-summary.md', summaryContent);
            
            // Save updated data to the correct file
            const targetFile = sourceFile || (fs.existsSync(DRV_JSON_PATH) ? DRV_JSON_PATH : FALLBACK_JSON_PATH);
            const totalChanges = newlyPassedCount + newlyBlockedCount + newlyUnknownCount;
            if (totalChanges > 0 || cleanupCount > 0) {
                console.log(`Updated LoadsDespiteHVCI for ${totalChanges} drivers (${newlyPassedCount} allowed, ${newlyBlockedCount} blocked, ${newlyUnknownCount} unknown)`);
                if (cleanupCount > 0) {
                    console.log(`Cleaned up HVCI tags in ${cleanupCount} drivers`);
                }
                fs.writeFileSync(targetFile, JSON.stringify(driversData, null, 2));
                
                // Set output for GitHub Actions
                console.log(`::set-output name=changes::${totalChanges}`);
                console.log(`::set-output name=newly_allowed::${newlyPassedCount}`);
                console.log(`::set-output name=newly_blocked::${newlyBlockedCount}`);
                console.log(`::set-output name=newly_unknown::${newlyUnknownCount}`);
                console.log(`::set-output name=cleanup_count::${cleanupCount}`);
            } else {
                console.log('No LoadsDespiteHVCI properties to update');
                // Still update metadata
                fs.writeFileSync(targetFile, JSON.stringify(driversData, null, 2));
                console.log(`::set-output name=changes::0`);
                console.log(`::set-output name=cleanup_count::0`);
            }
            
            console.log(`Total LoadsDespiteHVCI status: ${totalHvciPassedCount} TRUE, ${totalHvciBlockedCount} FALSE, ${totalHvciUnknownCount} null/undefined`);
        }
        
        updateDriversJSON().catch(console.error);
        EOF
        
    - name: Execute HVCI tagging script
      id: hvci-check
      run: node hvci-tagger.js
      
    - name: Display results
      run: |
        echo "=========================================="
        echo "           HVCI UPDATE RESULTS"
        echo "=========================================="
        if [ -f "hvci-summary.md" ]; then
          echo "HVCI check completed successfully!"
          echo ""
          
          # Extract key metrics from summary
          if grep -q "Newly Allowed Drivers:" hvci-summary.md; then
            NEWLY_ALLOWED=$(grep "Newly Allowed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly allowed drivers (LoadsDespiteHVCI = TRUE): $NEWLY_ALLOWED"
          fi
          
          if grep -q "Newly Blocked Drivers:" hvci-summary.md; then
            NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly blocked drivers (LoadsDespiteHVCI = FALSE): $NEWLY_BLOCKED"
          fi
          
          if grep -q "Newly Unknown Drivers:" hvci-summary.md; then
            NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly unknown drivers: $NEWLY_UNKNOWN"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = TRUE:" hvci-summary.md; then
            TOTAL_TRUE=$(grep "Total LoadsDespiteHVCI = TRUE:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = TRUE: $TOTAL_TRUE"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = FALSE:" hvci-summary.md; then
            TOTAL_FALSE=$(grep "Total LoadsDespiteHVCI = FALSE:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = FALSE: $TOTAL_FALSE"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = null/undefined:" hvci-summary.md; then
            TOTAL_NULL=$(grep "Total LoadsDespiteHVCI = null/undefined:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = null/undefined: $TOTAL_NULL"
          fi
          
          echo ""
          echo "Detailed summary available in workflow summary."
        else
          echo "No summary file generated - check may have failed"
        fi
        echo "=========================================="
      
    - name: Check for changes
      id: git-check
      run: |
        if [ -f "data/drv.json" ]; then
          git diff --exit-code data/drv.json || echo "changed=true" >> $GITHUB_OUTPUT
        elif [ -f "data/drvj.json" ]; then
          git diff --exit-code data/drvj.json || echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "No JSON file found to check for changes"
          exit 1
        fi
        
    - name: Commit and push changes
      if: steps.git-check.outputs.changed == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add the correct JSON file
        if [ -f "data/drv.json" ]; then
          git add data/drv.json
          JSON_FILE="data/drv.json"
        elif [ -f "data/drvj.json" ]; then
          git add data/drvj.json
          JSON_FILE="data/drvj.json"
        else
          echo "No JSON file found to commit"
          exit 1
        fi
        
        # Create detailed commit message
        COMMIT_MSG="Update LoadsDespiteHVCI using Microsoft Official Blocklist"
        
        if [ -f "hvci-summary.md" ]; then
          # Extract summary info for commit message
          NEWLY_ALLOWED=$(grep "Newly Allowed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Microsoft Official Vulnerable Driver Blocklist
        - Source: https://aka.ms/VulnerableDriverBlockList
        - Property updated: LoadsDespiteHVCI
        - File updated: $JSON_FILE
        - Newly allowed drivers (TRUE): $NEWLY_ALLOWED
        - Newly blocked drivers (FALSE): $NEWLY_BLOCKED
        - Newly detected unknown: $NEWLY_UNKNOWN
        - Cleaned up legacy HVCI tags
        - Analysis based on official Microsoft XML blocklist"
        else
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Microsoft Official Vulnerable Driver Blocklist
        - Source: https://aka.ms/VulnerableDriverBlockList"
        fi
        
        git commit -m "$COMMIT_MSG"
        
        echo "Pushing changes..."
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create workflow summary
      run: |
        echo "## HVCI LoadsDespiteHVCI Update Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Date:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "**Previous workflow:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous workflow status:** ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "**Source:** [Microsoft Official Vulnerable Driver Blocklist](https://aka.ms/VulnerableDriverBlockList)" >> $GITHUB_STEP_SUMMARY
        echo "**Method:** Comprehensive HVCI policy analysis (following Trail of Bits methodology)" >> $GITHUB_STEP_SUMMARY
        echo "**Property Updated:** LoadsDespiteHVCI" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Add detailed results from the check script
        if [ -f "hvci-summary.md" ]; then
          cat hvci-summary.md >> $GITHUB_STEP_SUMMARY
        else
          echo "No summary file generated - check may have failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "**About HVCI**: Hypervisor-protected Code Integrity (HVCI) uses hardware virtualization features to protect kernel mode processes against the injection and execution of malicious or unverified code. This comprehensive analysis uses the official Microsoft Vulnerable Driver Blocklist which contains multiple blocking mechanisms including hash-based rules, certificate restrictions, version limits, and filename rules. The LoadsDespiteHVCI property indicates whether a driver can load despite HVCI being enabled (TRUE for drivers not in blocklist) or is blocked by HVCI (FALSE for drivers blocked by any HVCI policy rule)." >> $GITHUB_STEP_SUMMARY
        
    - name: Upload summary artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: hvci-update-summary
        path: |
          hvci-summary.md
          hvci_drivers.csv
          hvci_analysis_summary.txt
        retention-days: 30
