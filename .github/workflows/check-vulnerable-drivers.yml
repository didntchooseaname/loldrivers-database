name: "HVCI Tag Update"

on:
  schedule:
    # Runs weekly on Mondays at 02:00 UTC
    - cron: '0 2 * * 1'
  workflow_dispatch: # Allow manual trigger
  workflow_run:
    workflows: ["Update LOLDrivers Data"]  # Name of the data update workflow
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  actions: read

jobs:
  run_powershell:
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    - name: Run PowerShell script
      run: |
        # Download Microsoft's official HVCI blocklist
        Write-Host "Downloading Microsoft HVCI Vulnerable Driver Blocklist..."
        Invoke-WebRequest -Uri "        echo "- **Source**: [Microsoft Official Vulnerable Driver Blocklist](https://aka.ms/VulnerableDriverBlockList)" >> $GITHUB_STEP_SUMMARY
        echo "- **Method**: XML blocklist parsing and hash comparison" >> $GITHUB_STEP_SUMMARYttps://aka.ms/VulnerableDriverBlockList" -OutFile "VulnerableDriverBlockList.zip"
        
        # Extract the zip file
        Write-Host "Extracting blocklist ZIP file..."
        Expand-Archive -Path "VulnerableDriverBlockList.zip" -DestinationPath "blocklist" -Force
        
        # Find XML files in the extracted content
        $xmlFiles = Get-ChildItem -Path "blocklist" -Filter "*.xml" -Recurse
        Write-Host "Found $($xmlFiles.Count) XML file(s):"
        $xmlFiles | ForEach-Object { Write-Host "  - $($_.FullName)" }
        
        # Look specifically for SiPolicy_Enforced_Server2016.xml in VulnerableDriverBlockList folder
        $targetXmlFile = Get-ChildItem -Path "blocklist" -Filter "SiPolicy_Enforced_Server2016.xml" -Recurse | Select-Object -First 1
        
        if (-not $targetXmlFile) {
            Write-Host "SiPolicy_Enforced_Server2016.xml not found, looking for any XML file in VulnerableDriverBlockList folder..."
            $targetXmlFile = Get-ChildItem -Path "blocklist\VulnerableDriverBlockList" -Filter "*.xml" -ErrorAction SilentlyContinue | Select-Object -First 1
        }
        
        if (-not $targetXmlFile) {
            Write-Error "No SiPolicy_Enforced_Server2016.xml or other XML files found in VulnerableDriverBlockList folder"
            exit 1
        }
        
        $xmlFile = $targetXmlFile.FullName
        Write-Host "Using XML file: $xmlFile"
        
        # Parse the XML HVCI policy (following Trail of Bits logic)
        Write-Host "Parsing XML HVCI policy..."
        [xml]$policy = Get-Content -Path $xmlFile -Raw
        
        # Extract policy components following Trail of Bits approach
        $fileRules = $policy.SiPolicy.FileRules
        $signers = $policy.SiPolicy.Signers.Signer
        
        Write-Host "Found file rules: $($fileRules.ChildNodes.Count)"
        Write-Host "Found signers: $($signers.Count)"
        
        # Initialize collections for policy analysis
        $blockedHashes = @{}
        $blockedSigners = @{}
        $blockedVersions = @{}
        $blockedFilenames = @{}
        
        # Extract blocked hashes from Deny rules
        if ($fileRules.Deny) {
            foreach ($denyRule in $fileRules.Deny) {
                if ($denyRule.Hash) {
                    $hashValue = $denyRule.Hash.Trim().ToUpper() -replace '[^A-F0-9]', ''
                    if ($hashValue.Length -ge 32) {
                        if ($hashValue.Length -eq 32) {
                            $blockedHashes[$hashValue] = "MD5"
                        } elseif ($hashValue.Length -eq 40) {
                            $blockedHashes[$hashValue] = "SHA1"
                        } elseif ($hashValue.Length -eq 64) {
                            $blockedHashes[$hashValue] = "SHA256"
                        }
                    }
                }
                
                # Extract filename restrictions
                if ($denyRule.FileName) {
                    $blockedFilenames[$denyRule.FileName] = $denyRule.MaximumFileVersion
                    if ($denyRule.MaximumFileVersion) {
                        $blockedVersions[$denyRule.FileName] = $denyRule.MaximumFileVersion
                    }
                }
            }
        }
        
        # Extract blocked signers/certificates
        if ($signers) {
            foreach ($signer in $signers) {
                if ($signer.CertRoot -and $signer.CertRoot.Value) {
                    $tbsHash = $signer.CertRoot.Value.ToLower()
                    $blockedSigners[$tbsHash] = @{
                        Name = $signer.Name
                        FileAttribRef = $signer.FileAttribRef
                    }
                }
            }
        }
        
        # Create helper functions following Trail of Bits logic
        function Test-BlockedHash($driver) {
            $driverHashes = @(
                $driver.MD5,
                $driver.SHA1, 
                $driver.SHA256,
                $driver.Authentihash.MD5,
                $driver.Authentihash.SHA1,
                $driver.Authentihash.SHA256
            ) | Where-Object { $_ -and $_.Length -ge 32 }
            
            foreach ($hash in $driverHashes) {
                $cleanHash = $hash.Trim().ToUpper() -replace '[^A-F0-9]', ''
                if ($blockedHashes.ContainsKey($cleanHash)) {
                    return @{
                        IsBlocked = $true
                        MatchedHash = $cleanHash
                        HashType = $blockedHashes[$cleanHash]
                        Reason = "Hash blocked"
                    }
                }
            }
            return @{ IsBlocked = $false }
        }
        
        function Test-BlockedSigner($driver) {
            if (-not $driver.Signatures -or -not $driver.Signatures.Certificates) {
                return @{ IsBlocked = $false }
            }
            
            # Get file attribute for this filename
            $fileAttrib = $fileRules.FileAttrib | Where-Object { $_.FileName -eq $driver.OriginalFilename }
            
            foreach ($cert in $driver.Signatures.Certificates) {
                $certHashes = @(
                    $cert.TBS.MD5,
                    $cert.TBS.SHA1,
                    $cert.TBS.SHA256,
                    $cert.TBS.SHA384
                ) | Where-Object { $_ } | ForEach-Object { $_.ToLower() }
                
                foreach ($certHash in $certHashes) {
                    if ($blockedSigners.ContainsKey($certHash)) {
                        $signer = $blockedSigners[$certHash]
                        $blockedFiles = $signer.FileAttribRef
                        
                        # If no specific file restrictions or this file is in the blocked list
                        if (-not $blockedFiles -or ($blockedFiles.RuleID -contains $fileAttrib.ID)) {
                            return @{
                                IsBlocked = $true
                                MatchedCert = $certHash
                                SignerName = $signer.Name
                                Reason = "Certificate blocked"
                            }
                        }
                    }
                }
            }
            return @{ IsBlocked = $false }
        }
        
        function Test-BlockedVersion($driver) {
            if (-not $driver.OriginalFilename -or -not $driver.FileVersion) {
                return @{ IsBlocked = $false }
            }
            
            $maxVersion = $blockedVersions[$driver.OriginalFilename]
            if ($maxVersion) {
                try {
                    # Clean and parse version string
                    $driverVersion = ($driver.FileVersion -replace ',\s*', '.').Split(' ')[0]
                    if ([version]$driverVersion -le [version]$maxVersion) {
                        return @{
                            IsBlocked = $true
                            MaxVersion = $maxVersion
                            DriverVersion = $driverVersion
                            Reason = "Version blocked"
                        }
                    }
                } catch {
                    # Version parsing failed, skip version check
                }
            }
            return @{ IsBlocked = $false }
        }
        
        Write-Host "Extracted HVCI policy components:"
        Write-Host "  - Blocked hashes: $($blockedHashes.Count)"
        Write-Host "  - Blocked signers: $($blockedSigners.Count)"  
        Write-Host "  - Version restrictions: $($blockedVersions.Count)"
        Write-Host "  - Filename restrictions: $($blockedFilenames.Count)"
        
        # Load local LOLDrivers data from the repository
        Write-Host "Loading local LOLDrivers data from repository..."
        
        # Check if we're in a git repository and load the local file
        $localJsonPath = "data\drv.json"
        if (-not (Test-Path $localJsonPath)) {
            $localJsonPath = "data\drvj.json"  # Try alternative name
        }
        
        if (-not (Test-Path $localJsonPath)) {
            Write-Error "Could not find local drv.json or drvj.json file in data folder"
            exit 1
        }
        
        Write-Host "Loading drivers from: $localJsonPath"
        $loldrivers = Get-Content -Path $localJsonPath -Raw | ConvertFrom-Json
        
        if (-not $loldrivers) {
            Write-Error "Could not load LOLDrivers data from local file"
            exit 1
        }
        
        Write-Host "Processing $($loldrivers.Count) drivers from local LOLDrivers database..."
        
        # Analyze drivers using comprehensive HVCI logic (following Trail of Bits approach)
        $totalDrivers = 0
        $blockedCount = 0
        $allowedCount = 0
        $blockedDrivers = @()
        $allowedDrivers = @()
        
        foreach ($driver in $loldrivers) {
            if ($driver.KnownVulnerableSamples) {
                foreach ($sample in $driver.KnownVulnerableSamples) {
                    $totalDrivers++
                    
                    # Test all HVCI blocking conditions following Trail of Bits logic
                    $hashResult = Test-BlockedHash $sample
                    $signerResult = Test-BlockedSigner $sample  
                    $versionResult = Test-BlockedVersion $sample
                    
                    $isBlocked = $false
                    $blockReason = "Allowed by HVCI policy"
                    $matchedDetail = "N/A"
                    $matchedType = "N/A"
                    
                    # Check blocking conditions in order (following original script logic)
                    if ($hashResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $hashResult.Reason
                        $matchedDetail = $hashResult.MatchedHash
                        $matchedType = $hashResult.HashType
                    }
                    elseif ($versionResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $versionResult.Reason
                        $matchedDetail = "$($versionResult.DriverVersion) <= $($versionResult.MaxVersion)"
                        $matchedType = "Version"
                    }
                    elseif ($signerResult.IsBlocked) {
                        $isBlocked = $true
                        $blockReason = $signerResult.Reason
                        $matchedDetail = $signerResult.MatchedCert
                        $matchedType = "Certificate"
                    }
                    
                    # Create comprehensive driver result object
                    $driverResult = [PSCustomObject]@{
                        MD5 = $sample.MD5 -or "N/A"
                        SHA1 = $sample.SHA1 -or "N/A"
                        SHA256 = $sample.SHA256 -or "N/A"
                        AuthentiMD5 = if ($sample.Authentihash -and $sample.Authentihash.MD5) { $sample.Authentihash.MD5 } else { "N/A" }
                        AuthentiSHA1 = if ($sample.Authentihash -and $sample.Authentihash.SHA1) { $sample.Authentihash.SHA1 } else { "N/A" }
                        AuthentiSHA256 = if ($sample.Authentihash -and $sample.Authentihash.SHA256) { $sample.Authentihash.SHA256 } else { "N/A" }
                        Status = if ($isBlocked) { "Blocked" } else { "Allowed" }
                        BlockReason = $blockReason
                        MatchedDetail = $matchedDetail
                        MatchedType = $matchedType
                        DriverId = $driver.Id
                        Company = $sample.Company -or "Unknown"
                        Filename = $sample.Filename -or $sample.OriginalFilename -or "Unknown"
                        OriginalFilename = $sample.OriginalFilename -or "Unknown"
                        FileVersion = $sample.FileVersion -or "Unknown"
                        Description = $sample.Description -or "Unknown"
                    }
                    
                    if ($isBlocked) {
                        $blockedDrivers += $driverResult
                        $blockedCount++
                    } else {
                        $allowedDrivers += $driverResult
                        $allowedCount++
        
        # Output comprehensive analysis summary
        Write-Host "=========================================="
        Write-Host "        COMPREHENSIVE HVCI ANALYSIS"
        Write-Host "=========================================="
        Write-Host "Total drivers analyzed: $totalDrivers"
        Write-Host "Blocked drivers (blocked by HVCI): $blockedCount"
        Write-Host "Allowed drivers (can load with HVCI): $allowedCount"
        Write-Host ""
        Write-Host "HVCI Policy Components Found:"
        Write-Host "  - Blocked hashes: $($blockedHashes.Count)"
        Write-Host "  - Blocked signers/certificates: $($blockedSigners.Count)"  
        Write-Host "  - Version restrictions: $($blockedVersions.Count)"
        Write-Host "  - Filename restrictions: $($blockedFilenames.Count)"
        Write-Host "=========================================="
        
        # Create comprehensive CSV with all analysis information
        $csvContent = "MD5,SHA1,SHA256,AuthentiMD5,AuthentiSHA1,AuthentiSHA256,Status,BlockReason,MatchedDetail,MatchedType,DriverId,Company,Filename,OriginalFilename,FileVersion,Description`n"
        
        foreach ($driver in $blockedDrivers) {
            $csvContent += "`"$($driver.MD5)`",`"$($driver.SHA1)`",`"$($driver.SHA256)`",`"$($driver.AuthentiMD5)`",`"$($driver.AuthentiSHA1)`",`"$($driver.AuthentiSHA256)`",`"$($driver.Status)`",`"$($driver.BlockReason)`",`"$($driver.MatchedDetail)`",`"$($driver.MatchedType)`",`"$($driver.DriverId)`",`"$($driver.Company)`",`"$($driver.Filename)`",`"$($driver.OriginalFilename)`",`"$($driver.FileVersion)`",`"$($driver.Description)`"`n"
        }
        
        foreach ($driver in $allowedDrivers) {
            $csvContent += "`"$($driver.MD5)`",`"$($driver.SHA1)`",`"$($driver.SHA256)`",`"$($driver.AuthentiMD5)`",`"$($driver.AuthentiSHA1)`",`"$($driver.AuthentiSHA256)`",`"$($driver.Status)`",`"$($driver.BlockReason)`",`"$($driver.MatchedDetail)`",`"$($driver.MatchedType)`",`"$($driver.DriverId)`",`"$($driver.Company)`",`"$($driver.Filename)`",`"$($driver.OriginalFilename)`",`"$($driver.FileVersion)`",`"$($driver.Description)`"`n"
        }
        
        # Write CSV file
        $csvContent | Out-File -FilePath "hvci_drivers.csv" -Encoding UTF8
        
        # Create detailed analysis summary with breakdown by blocking reason
        $hashBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -like "*Hash*" }).Count
        $certBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -eq "Certificate" }).Count
        $versionBlocked = ($blockedDrivers | Where-Object { $_.MatchedType -eq "Version" }).Count
        
        $summaryContent = @"
# Comprehensive HVCI Blocklist Analysis Summary

## Analysis Details
- **Source**: Microsoft Official Vulnerable Driver Blocklist (following Trail of Bits methodology)
- **Blocklist URL**: https://aka.ms/VulnerableDriverBlockList
- **Analysis Date**: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")
- **XML File**: SiPolicy_Enforced_Server2016.xml
- **Local Data Source**: $localJsonPath
- **Analysis Method**: Comprehensive HVCI policy parsing (hash, certificate, version, filename rules)

## Results Summary
- **Total Drivers Analyzed**: $totalDrivers
- **Blocked Drivers**: $blockedCount
- **Allowed Drivers**: $allowedCount
- **Blocked Percentage**: $([math]::Round(($blockedCount / $totalDrivers) * 100, 2))%

## Blocking Reasons Breakdown
- **Hash-based blocks**: $hashBlocked drivers
- **Certificate-based blocks**: $certBlocked drivers  
- **Version-based blocks**: $versionBlocked drivers

## HVCI Policy Components Analyzed
- **Blocked Hashes**: $($blockedHashes.Count) (MD5, SHA1, SHA256, Authentihash)
- **Blocked Signers**: $($blockedSigners.Count) (Certificate TBS hashes)
- **Version Restrictions**: $($blockedVersions.Count) (MaximumFileVersion rules)
- **Filename Restrictions**: $($blockedFilenames.Count) (FileName rules)

## Analysis Methodology
This comprehensive analysis follows the Trail of Bits HVCI methodology which checks:
1. **Hash Matching**: Compares driver hashes (MD5, SHA1, SHA256, Authentihash) against blocked hash lists
2. **Certificate Validation**: Checks driver certificates against blocked signer TBS hashes
3. **Version Checking**: Validates driver versions against maximum allowed versions
4. **Filename Rules**: Applies filename-specific blocking rules

The analysis uses the official Microsoft Vulnerable Driver Blocklist XML policy file which contains FileRule entries with Deny rules for various driver attributes.
"@
- **XML File**: $($targetXmlFile.Name)
- **XML File Path**: $($targetXmlFile.FullName)
- **Local Data Source**: $localJsonPath
- **Total XML Rules**: $($fileRules.Count)
- **Extracted Hashes**: $($blockedHashes.Count)

## Results
- **Total Drivers Analyzed**: $totalDrivers
The analysis uses the official Microsoft Vulnerable Driver Blocklist XML policy file which contains FileRule entries with Deny rules for various driver attributes.

## Hash Distribution in Blocklist
"@
        
        # Add hash distribution statistics
        $hashStats = $blockedHashes.Values | Group-Object | Sort-Object Name
        foreach ($stat in $hashStats) {
            $summaryContent += "`n- **$($stat.Name)**: $($stat.Count) hashes"
        }
        
        # Add certificate distribution statistics
        if ($blockedSigners.Count -gt 0) {
            $summaryContent += "`n`n## Certificate/Signer Distribution"
            $summaryContent += "`n- **Total Blocked Signers**: $($blockedSigners.Count)"
        }
        
        # Add version restriction statistics  
        if ($blockedVersions.Count -gt 0) {
            $summaryContent += "`n`n## Version Restrictions"
            $summaryContent += "`n- **Files with Version Limits**: $($blockedVersions.Count)"
        }
        
        $summaryContent | Out-File -FilePath "hvci_analysis_summary.txt" -Encoding UTF8
        
        Write-Host "Comprehensive CSV file created: hvci_drivers.csv"
        Write-Host "Detailed summary file created: hvci_analysis_summary.txt"
        Write-Host ""
        Write-Host "Analysis complete! Found $blockedCount blocked and $allowedCount allowed drivers using comprehensive HVCI methodology."
        
    - name: Upload CSV
      uses: actions/upload-artifact@v4
      with:
        name: hvci_drivers
        path: |
          hvci_drivers.csv
          hvci_analysis_summary.txt

  run_node:
    needs: run_powershell
    runs-on: ubuntu-latest
    # Only run if previous workflow succeeded, or if triggered manually/by cron
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Download CSV
      uses: actions/download-artifact@v4
      with:
        name: hvci_drivers
        path: ./
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Create HVCI tagging script
      run: |
        cat > hvci-tagger.js << 'EOF'
        #!/usr/bin/env node
        
        import fs from 'fs';
        import { createReadStream } from 'fs';
        import { createInterface } from 'readline';
        
        const DRV_JSON_PATH = './data/drv.json';
        const FALLBACK_JSON_PATH = './data/drvj.json';
        const CSV_PATH = './hvci_drivers.csv';
        
        async function processCSV() {
            console.log('Reading HVCI CSV results...');
            
            const allowedHashes = new Set();
            const blockedHashes = new Set();
            const hashDetails = new Map(); // Store hash -> details mapping
            
            // Check if CSV exists and has content
            if (!fs.existsSync(CSV_PATH)) {
                console.log('No CSV file found, assuming no HVCI status available');
                return { allowedHashes, blockedHashes, hashDetails };
            }
            
            const fileStream = createReadStream(CSV_PATH);
            const rl = createInterface({
                input: fileStream,
                crlfDelay: Infinity
            });
            
            let lineNumber = 0;
            for await (const line of rl) {
                lineNumber++;
                if (lineNumber === 1) continue; // Skip header
                
                const columns = line.split(',');
                if (columns.length >= 4) {
                    const md5 = columns[0]?.replace(/"/g, '').trim();
                    const sha1 = columns[1]?.replace(/"/g, '').trim();
                    const sha256 = columns[2]?.replace(/"/g, '').trim();
                    const status = columns[3]?.replace(/"/g, '').trim();
                    
                    const hashes = [md5, sha1, sha256].filter(Boolean);
                    
                    hashes.forEach(hash => {
                        if (hash) {
                            const lowerHash = hash.toLowerCase();
                            hashDetails.set(lowerHash, {
                                md5, sha1, sha256, status,
                                type: hash === md5 ? 'MD5' : hash === sha1 ? 'SHA1' : 'SHA256'
                            });
                            
                            if (status === 'Allowed') {
                                allowedHashes.add(lowerHash);
                            } else if (status === 'Blocked') {
                                blockedHashes.add(lowerHash);
                            }
                        }
                    });
                }
            }
            
            console.log(`Found ${allowedHashes.size} allowed hashes and ${blockedHashes.size} blocked hashes from HVCI policy`);
            return { allowedHashes, blockedHashes, hashDetails };
        }
        
        function getDriverDisplayName(driver, sample) {
            // Get the best available name for the driver
            if (sample.Filename) return sample.Filename;
            if (sample.OriginalFilename) return sample.OriginalFilename;
            if (driver.Tags && driver.Tags.length > 0) {
                // Find a meaningful tag (not just HVCI tags)
                const meaningfulTag = driver.Tags.find(tag => 
                    !tag.includes('HVCI') && tag.length > 3
                );
                if (meaningfulTag) return meaningfulTag;
            }
            return 'Unknown Driver';
        }
        
        async function updateDriversJSON() {
            console.log('Loading drivers database...');
            
            let driversData;
            let sourceFile;
            try {
                driversData = JSON.parse(fs.readFileSync(DRV_JSON_PATH, 'utf8'));
                sourceFile = DRV_JSON_PATH;
                console.log(`Loaded drivers from ${DRV_JSON_PATH}`);
            } catch (error) {
                console.log(`Failed to load ${DRV_JSON_PATH}, trying fallback...`);
                try {
                    driversData = JSON.parse(fs.readFileSync(FALLBACK_JSON_PATH, 'utf8'));
                    sourceFile = FALLBACK_JSON_PATH;
                    console.log(`Loaded drivers from ${FALLBACK_JSON_PATH}`);
                } catch (fallbackError) {
                    console.error('Failed to load drivers data from both paths');
                    throw fallbackError;
                }
            }
            
            // Clean up any existing HVCI tags that might be present
            console.log('Cleaning up any existing HVCI tags...');
            let cleanupCount = 0;
            driversData.forEach(driver => {
                if (driver.Tags && Array.isArray(driver.Tags)) {
                    const originalLength = driver.Tags.length;
                    
                    // Remove any HVCI tags since we now use LoadsDespiteHVCI property
                    driver.Tags = driver.Tags.filter(tag => 
                        !tag.toLowerCase().includes('hvci')
                    );
                    
                    if (originalLength !== driver.Tags.length) {
                        cleanupCount++;
                        console.log(`Removed ${originalLength - driver.Tags.length} HVCI tags from driver ${driver.Id}`);
                    }
                }
            });
            
            console.log(`Cleaned up HVCI tags in ${cleanupCount} drivers (now using LoadsDespiteHVCI property)`);
            
            const { allowedHashes, blockedHashes, hashDetails } = await processCSV();
            
            let newlyPassedCount = 0;
            let newlyBlockedCount = 0;
            let newlyUnknownCount = 0;
            let totalHvciPassedCount = 0;
            let totalHvciBlockedCount = 0;
            let totalHvciUnknownCount = 0;
            
            const changes = {
                newlyPassed: [],
                newlyBlocked: [],
                newlyUnknown: [],
                summary: []
            };
            
            driversData.forEach(driver => {
                if (driver.KnownVulnerableSamples) {
                    driver.KnownVulnerableSamples.forEach(sample => {
                        const sampleHashes = [
                            sample.MD5?.toLowerCase(),
                            sample.SHA1?.toLowerCase(), 
                            sample.SHA256?.toLowerCase(),
                            sample.Authentihash?.MD5?.toLowerCase(),
                            sample.Authentihash?.SHA1?.toLowerCase(),
                            sample.Authentihash?.SHA256?.toLowerCase()
                        ].filter(Boolean);
                        
                        let isAllowed = false;
                        let isBlocked = false;
                        let matchedHash = null;
                        let matchedHashType = null;
                        
                        // Check if any hash is in the allowed or blocked lists
                        for (const hash of sampleHashes) {
                            if (allowedHashes.has(hash)) {
                                isAllowed = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                            if (blockedHashes.has(hash)) {
                                isBlocked = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                        }
                        
                        // HVCI LoadsDespiteHVCI logic:
                        // - If driver has Allowed status → "LoadsDespiteHVCI": "TRUE"
                        // - If driver has Blocked status → "LoadsDespiteHVCI": "FALSE"
                        // - If driver is not in CSV → leave as is or set to null
                        
                        const currentLoadsDespiteHVCI = sample.LoadsDespiteHVCI;
                        let newLoadsDespiteHVCI = null;
                        
                        if (isAllowed) {
                            // Driver is allowed by HVCI policy
                            newLoadsDespiteHVCI = "TRUE";
                            if (currentLoadsDespiteHVCI !== "TRUE") {
                                newlyPassedCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                changes.newlyPassed.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: matchedHash.toUpperCase(),
                                    hashType: matchedHashType,
                                    company: sample.Company || 'Unknown',
                                    previousValue: currentLoadsDespiteHVCI || 'null',
                                    newValue: 'TRUE'
                                });
                            }
                            
                        } else if (isBlocked) {
                            // Driver is blocked by HVCI policy
                            newLoadsDespiteHVCI = "FALSE";
                            if (currentLoadsDespiteHVCI !== "FALSE") {
                                newlyBlockedCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                changes.newlyBlocked.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: matchedHash.toUpperCase(),
                                    hashType: matchedHashType,
                                    company: sample.Company || 'Unknown',
                                    previousValue: currentLoadsDespiteHVCI || 'null',
                                    newValue: 'FALSE'
                                });
                            }
                            
                        } else {
                            // Driver is not in CSV, leave LoadsDespiteHVCI as is
                            if (currentLoadsDespiteHVCI === undefined || currentLoadsDespiteHVCI === null) {
                                newlyUnknownCount++;
                                const driverName = getDriverDisplayName(driver, sample);
                                const firstHash = sampleHashes[0] || 'Unknown';
                                changes.newlyUnknown.push({
                                    driverId: driver.Id,
                                    driverName,
                                    hash: firstHash.toUpperCase(),
                                    hashType: 'N/A',
                                    company: sample.Company || 'Unknown',
                                    previousValue: 'undefined',
                                    newValue: 'unchanged'
                                });
                            }
                        }
                        
                        // Update the LoadsDespiteHVCI property if needed
                        if (newLoadsDespiteHVCI !== null) {
                            sample.LoadsDespiteHVCI = newLoadsDespiteHVCI;
                        }
                        
                        // Count totals
                        if (sample.LoadsDespiteHVCI === "TRUE") {
                            totalHvciPassedCount++;
                        }
                        if (sample.LoadsDespiteHVCI === "FALSE") {
                            totalHvciBlockedCount++;
                        }
                        if (sample.LoadsDespiteHVCI === undefined || sample.LoadsDespiteHVCI === null) {
                            totalHvciUnknownCount++;
                        }
                    });
                }
            });
            
            // Add metadata
            if (!driversData._metadata) {
                driversData._metadata = {};
            }
            driversData._metadata.hvciCheck = {
                lastCheck: new Date().toISOString(),
                newlyAllowedDrivers: newlyPassedCount,
                newlyBlockedDrivers: newlyBlockedCount,
                newlyUnknownDrivers: newlyUnknownCount,
                totalLoadsTrue: totalHvciPassedCount,
                totalLoadsFalse: totalHvciBlockedCount,
                totalLoadsUnknown: totalHvciUnknownCount,
                source: 'Microsoft Official Vulnerable Driver Blocklist',
                sourceUrl: 'https://aka.ms/VulnerableDriverBlockList',
                method: 'LoadsDespiteHVCI property update via XML blocklist',
                triggerEvent: process.env.GITHUB_EVENT_NAME || 'manual'
            };
            
            // Create detailed summary
            let summaryContent = '# HVCI LoadsDespiteHVCI Update Summary\n\n';
            summaryContent += `**Date:** ${new Date().toISOString()}\n`;
            summaryContent += `**Trigger:** ${process.env.GITHUB_EVENT_NAME || 'manual'}\n`;
            summaryContent += `**Method:** Microsoft Official Vulnerable Driver Blocklist\n`;
            summaryContent += `**Blocklist Source:** https://aka.ms/VulnerableDriverBlockList\n`;
            summaryContent += `**Property Updated:** LoadsDespiteHVCI\n`;
            summaryContent += `**Newly Allowed Drivers:** ${newlyPassedCount}\n`;
            summaryContent += `**Newly Blocked Drivers:** ${newlyBlockedCount}\n`;
            summaryContent += `**Newly Unknown Drivers:** ${newlyUnknownCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = TRUE:** ${totalHvciPassedCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = FALSE:** ${totalHvciBlockedCount}\n`;
            summaryContent += `**Total LoadsDespiteHVCI = null/undefined:** ${totalHvciUnknownCount}\n\n`;
            
            summaryContent += '## Analysis Method\n\n';
            summaryContent += 'This analysis uses the official Microsoft Vulnerable Driver Blocklist which:\n';
            summaryContent += '1. Downloads the official blocklist from https://aka.ms/VulnerableDriverBlockList\n';
            summaryContent += '2. Extracts XML files from the ZIP archive\n';
            summaryContent += '3. Parses XML FileRule entries to extract blocked driver hashes\n';
            summaryContent += '4. Compares LOLDrivers database against the blocklist\n';
            summaryContent += '5. Determines blocked/allowed status based on hash matches\n\n';
            summaryContent += '**LoadsDespiteHVCI Logic:**\n';
            summaryContent += '- Drivers **NOT** in Microsoft blocklist → **LoadsDespiteHVCI = "TRUE"**\n';
            summaryContent += '- Drivers **IN** Microsoft blocklist → **LoadsDespiteHVCI = "FALSE"**\n';
            summaryContent += '- Drivers with insufficient hash data → **LoadsDespiteHVCI = unchanged**\n\n';
            
            if (changes.newlyBlocked.length > 0) {
                summaryContent += '## Newly Blocked Drivers (LoadsDespiteHVCI = FALSE)\n\n';
                summaryContent += '*These drivers are in the Microsoft blocklist and cannot load with HVCI:*\n\n';
                changes.newlyBlocked.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - Previous: ${item.previousValue} → New: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyPassed.length > 0) {
                summaryContent += '## Newly Allowed Drivers (LoadsDespiteHVCI = TRUE)\n\n';
                summaryContent += '*These drivers are NOT in the Microsoft blocklist and can load with HVCI:*\n\n';
                changes.newlyPassed.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - Previous: ${item.previousValue} → New: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyUnknown.length > 0) {
                summaryContent += '## Newly Detected Unknown Drivers\n\n';
                summaryContent += '*These drivers have insufficient hash data for blocklist comparison:*\n\n';
                changes.newlyUnknown.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - Status: Insufficient hash data for comparison\n`;
                    summaryContent += `   - Company: ${item.company}\n`;
                    summaryContent += `   - LoadsDespiteHVCI: ${item.newValue}\n\n`;
                });
            }
            
            if (changes.newlyPassed.length === 0 && changes.newlyBlocked.length === 0 && changes.newlyUnknown.length === 0) {
                summaryContent += '## No Changes\n\nNo LoadsDespiteHVCI properties were updated in this run.\n';
                summaryContent += 'All drivers already have current HVCI policy status.\n';
            }
            
            fs.writeFileSync('hvci-summary.md', summaryContent);
            
            // Save updated data to the correct file
            const targetFile = sourceFile || (fs.existsSync(DRV_JSON_PATH) ? DRV_JSON_PATH : FALLBACK_JSON_PATH);
            const totalChanges = newlyPassedCount + newlyBlockedCount + newlyUnknownCount;
            if (totalChanges > 0 || cleanupCount > 0) {
                console.log(`Updated LoadsDespiteHVCI for ${totalChanges} drivers (${newlyPassedCount} allowed, ${newlyBlockedCount} blocked, ${newlyUnknownCount} unknown)`);
                if (cleanupCount > 0) {
                    console.log(`Cleaned up HVCI tags in ${cleanupCount} drivers`);
                }
                fs.writeFileSync(targetFile, JSON.stringify(driversData, null, 2));
                
                // Set output for GitHub Actions
                console.log(`::set-output name=changes::${totalChanges}`);
                console.log(`::set-output name=newly_allowed::${newlyPassedCount}`);
                console.log(`::set-output name=newly_blocked::${newlyBlockedCount}`);
                console.log(`::set-output name=newly_unknown::${newlyUnknownCount}`);
                console.log(`::set-output name=cleanup_count::${cleanupCount}`);
            } else {
                console.log('No LoadsDespiteHVCI properties to update');
                // Still update metadata
                fs.writeFileSync(targetFile, JSON.stringify(driversData, null, 2));
                console.log(`::set-output name=changes::0`);
                console.log(`::set-output name=cleanup_count::0`);
            }
            
            console.log(`Total LoadsDespiteHVCI status: ${totalHvciPassedCount} TRUE, ${totalHvciBlockedCount} FALSE, ${totalHvciUnknownCount} null/undefined`);
        }
        
        updateDriversJSON().catch(console.error);
        EOF
        
    - name: Execute HVCI tagging script
      id: hvci-check
      run: node hvci-tagger.js
      
    - name: Display results
      run: |
        echo "=========================================="
        echo "           HVCI UPDATE RESULTS"
        echo "=========================================="
        if [ -f "hvci-summary.md" ]; then
          echo "HVCI check completed successfully!"
          echo ""
          
          # Extract key metrics from summary
          if grep -q "Newly Allowed Drivers:" hvci-summary.md; then
            NEWLY_ALLOWED=$(grep "Newly Allowed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly allowed drivers (LoadsDespiteHVCI = TRUE): $NEWLY_ALLOWED"
          fi
          
          if grep -q "Newly Blocked Drivers:" hvci-summary.md; then
            NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly blocked drivers (LoadsDespiteHVCI = FALSE): $NEWLY_BLOCKED"
          fi
          
          if grep -q "Newly Unknown Drivers:" hvci-summary.md; then
            NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly unknown drivers: $NEWLY_UNKNOWN"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = TRUE:" hvci-summary.md; then
            TOTAL_TRUE=$(grep "Total LoadsDespiteHVCI = TRUE:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = TRUE: $TOTAL_TRUE"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = FALSE:" hvci-summary.md; then
            TOTAL_FALSE=$(grep "Total LoadsDespiteHVCI = FALSE:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = FALSE: $TOTAL_FALSE"
          fi
          
          if grep -q "Total LoadsDespiteHVCI = null/undefined:" hvci-summary.md; then
            TOTAL_NULL=$(grep "Total LoadsDespiteHVCI = null/undefined:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total LoadsDespiteHVCI = null/undefined: $TOTAL_NULL"
          fi
          
          echo ""
          echo "Detailed summary available in workflow summary."
        else
          echo "No summary file generated - check may have failed"
        fi
        echo "=========================================="
      
    - name: Check for changes
      id: git-check
      run: |
        if [ -f "data/drv.json" ]; then
          git diff --exit-code data/drv.json || echo "changed=true" >> $GITHUB_OUTPUT
        elif [ -f "data/drvj.json" ]; then
          git diff --exit-code data/drvj.json || echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "No JSON file found to check for changes"
          exit 1
        fi
        
    - name: Commit and push changes
      if: steps.git-check.outputs.changed == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add the correct JSON file
        if [ -f "data/drv.json" ]; then
          git add data/drv.json
          JSON_FILE="data/drv.json"
        elif [ -f "data/drvj.json" ]; then
          git add data/drvj.json
          JSON_FILE="data/drvj.json"
        else
          echo "No JSON file found to commit"
          exit 1
        fi
        
        # Create detailed commit message
        COMMIT_MSG="Update LoadsDespiteHVCI using Microsoft Official Blocklist"
        
        if [ -f "hvci-summary.md" ]; then
          # Extract summary info for commit message
          NEWLY_ALLOWED=$(grep "Newly Allowed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Microsoft Official Vulnerable Driver Blocklist
        - Source: https://aka.ms/VulnerableDriverBlockList
        - Property updated: LoadsDespiteHVCI
        - File updated: $JSON_FILE
        - Newly allowed drivers (TRUE): $NEWLY_ALLOWED
        - Newly blocked drivers (FALSE): $NEWLY_BLOCKED
        - Newly detected unknown: $NEWLY_UNKNOWN
        - Cleaned up legacy HVCI tags
        - Analysis based on official Microsoft XML blocklist"
        else
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Microsoft Official Vulnerable Driver Blocklist
        - Source: https://aka.ms/VulnerableDriverBlockList"
        fi
        
        git commit -m "$COMMIT_MSG"
        
        echo "Pushing changes..."
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create workflow summary
      run: |
        echo "## HVCI LoadsDespiteHVCI Update Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Date:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "**Previous workflow:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous workflow status:** ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "**Source:** [Trail of Bits HVCI Analysis](https://github.com/trailofbits/HVCI-loldrivers-check)" >> $GITHUB_STEP_SUMMARY
        echo "**Property Updated:** LoadsDespiteHVCI" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Add detailed results from the check script
        if [ -f "hvci-summary.md" ]; then
          cat hvci-summary.md >> $GITHUB_STEP_SUMMARY
        else
          echo "No summary file generated - check may have failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "**About HVCI**: Hypervisor-protected Code Integrity (HVCI) uses hardware virtualization features to protect kernel mode processes against the injection and execution of malicious or unverified code. This analysis uses the official Microsoft Vulnerable Driver Blocklist which contains hash-based rules for drivers that are blocked by HVCI. The LoadsDespiteHVCI property indicates whether a driver can load despite HVCI being enabled (TRUE for drivers not in blocklist) or is blocked by HVCI (FALSE for drivers in blocklist)." >> $GITHUB_STEP_SUMMARY
        
    - name: Upload summary artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: hvci-update-summary
        path: |
          hvci-summary.md
          hvci_drivers.csv
          hvci_analysis_summary.txt
        retention-days: 30
