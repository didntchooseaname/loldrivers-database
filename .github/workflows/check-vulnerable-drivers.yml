name: "HVCI Tag Update"

on:
  schedule:
    # Runs weekly on Mondays at 02:00 UTC
    - cron: '0 2 * * 1'
  workflow_dispatch: # Allow manual trigger
  workflow_run:
    workflows: ["Update LOLDrivers Data"]  # Name of the data update workflow
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  actions: read

jobs:
  run_powershell:
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Run PowerShell script
      run: |
        # Download and run the Trail of Bits HVCI check script
        Invoke-WebRequest -Uri "https://raw.githubusercontent.com/trailofbits/HVCI-loldrivers-check/refs/heads/main/check_allowed_drivers.ps1" -OutFile "check_allowed_drivers.ps1"
        $output = ./check_allowed_drivers.ps1
        
        # Parse the output and create a structured CSV
        $lines = $output -split "`n"
        $inAllowedSection = $false
        $allowedDrivers = @()
        $blockedDrivers = @()
        
        # First, get the LOLDrivers data to identify all hashes
        $loldrivers = Invoke-WebRequest -Uri https://www.loldrivers.io/api/drivers.json | ConvertFrom-Json -AsHashTable
        $allDriverHashes = @{}
        
        foreach ($driver in $loldrivers.KnownVulnerableSamples) {
            $hashes = @($driver.MD5, $driver.SHA1, $driver.SHA256)
            foreach ($hash in $hashes) {
                if ($hash) {
                    $allDriverHashes["$($driver.MD5):$($driver.SHA1):$($driver.SHA256)"] = $true
                }
            }
        }
        
        # Parse allowed drivers from Trail of Bits output
        foreach ($line in $lines) {
            if ($line -match "^Allowed drivers:") {
                $inAllowedSection = $true
                continue
            }
            if ($inAllowedSection -and $line -match "MD5:(\w+) SHA1:(\w+) SHA256:(\w+)") {
                $allowedDrivers += [PSCustomObject]@{
                    MD5 = $matches[1]
                    SHA1 = $matches[2] 
                    SHA256 = $matches[3]
                    Status = "Allowed"
                }
            }
        }
        
        # Identify blocked drivers (those in LOLDrivers but NOT in allowed list)
        $allowedHashSet = @{}
        foreach ($allowed in $allowedDrivers) {
            $allowedHashSet["$($allowed.MD5):$($allowed.SHA1):$($allowed.SHA256)"] = $true
        }
        
        foreach ($hashKey in $allDriverHashes.Keys) {
            if (-not $allowedHashSet.ContainsKey($hashKey)) {
                $hashParts = $hashKey -split ":"
                $blockedDrivers += [PSCustomObject]@{
                    MD5 = $hashParts[0]
                    SHA1 = $hashParts[1]
                    SHA256 = $hashParts[2]
                    Status = "Blocked"
                }
            }
        }
        
        # Output summary
        $totalOutput = $output | Out-String
        if ($totalOutput -match "Number of blocked drivers: (\d+)") {
            Write-Host "Found $($matches[1]) blocked drivers from Trail of Bits analysis"
        }
        if ($totalOutput -match "Number of allowed drivers: (\d+)") {
            Write-Host "Found $($matches[1]) allowed drivers from Trail of Bits analysis"
        }
        Write-Host "Parsed $($allowedDrivers.Count) allowed and $($blockedDrivers.Count) blocked drivers for CSV"
        
        # Create CSV with both allowed and blocked results
        $csvContent = "MD5,SHA1,SHA256,Status`n"
        foreach ($driver in $allowedDrivers) {
            $csvContent += "$($driver.MD5),$($driver.SHA1),$($driver.SHA256),$($driver.Status)`n"
        }
        foreach ($driver in $blockedDrivers) {
            $csvContent += "$($driver.MD5),$($driver.SHA1),$($driver.SHA256),$($driver.Status)`n"
        }
        
        # Write CSV file
        $csvContent | Out-File -FilePath "hvci_drivers.csv" -Encoding UTF8
        
    - name: Upload CSV
      uses: actions/upload-artifact@v4
      with:
        name: hvci_drivers
        path: hvci_drivers.csv

  run_node:
    needs: run_powershell
    runs-on: ubuntu-latest
    # Only run if previous workflow succeeded, or if triggered manually/by cron
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Download CSV
      uses: actions/download-artifact@v4
      with:
        name: hvci_drivers
        path: ./
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Create HVCI tagging script
      run: |
        cat > hvci-tagger.js << 'EOF'
        #!/usr/bin/env node
        
        import fs from 'fs';
        import { createReadStream } from 'fs';
        import { createInterface } from 'readline';
        
        const DRV_JSON_PATH = './data/drv.json';
        const CSV_PATH = './hvci_drivers.csv';
        
        async function processCSV() {
            console.log('Reading HVCI CSV results...');
            
            const allowedHashes = new Set();
            const blockedHashes = new Set();
            const hashDetails = new Map(); // Store hash -> details mapping
            
            // Check if CSV exists and has content
            if (!fs.existsSync(CSV_PATH)) {
                console.log('No CSV file found, assuming no HVCI status available');
                return { allowedHashes, blockedHashes, hashDetails };
            }
            
            const fileStream = createReadStream(CSV_PATH);
            const rl = createInterface({
                input: fileStream,
                crlfDelay: Infinity
            });
            
            let lineNumber = 0;
            for await (const line of rl) {
                lineNumber++;
                if (lineNumber === 1) continue; // Skip header
                
                const columns = line.split(',');
                if (columns.length >= 4) {
                    const md5 = columns[0]?.replace(/"/g, '').trim();
                    const sha1 = columns[1]?.replace(/"/g, '').trim();
                    const sha256 = columns[2]?.replace(/"/g, '').trim();
                    const status = columns[3]?.replace(/"/g, '').trim();
                    
                    const hashes = [md5, sha1, sha256].filter(Boolean);
                    
                    hashes.forEach(hash => {
                        if (hash) {
                            const lowerHash = hash.toLowerCase();
                            hashDetails.set(lowerHash, {
                                md5, sha1, sha256, status,
                                type: hash === md5 ? 'MD5' : hash === sha1 ? 'SHA1' : 'SHA256'
                            });
                            
                            if (status === 'Allowed') {
                                allowedHashes.add(lowerHash);
                            } else if (status === 'Blocked') {
                                blockedHashes.add(lowerHash);
                            }
                        }
                    });
                }
            }
            
            console.log(`Found ${allowedHashes.size} allowed hashes and ${blockedHashes.size} blocked hashes from HVCI policy`);
            return { allowedHashes, blockedHashes, hashDetails };
        }
        
        function getDriverDisplayName(driver, sample) {
            // Get the best available name for the driver
            if (sample.Filename) return sample.Filename;
            if (sample.OriginalFilename) return sample.OriginalFilename;
            if (driver.Tags && driver.Tags.length > 0) {
                // Find a meaningful tag (not just HVCI tags)
                const meaningfulTag = driver.Tags.find(tag => 
                    !tag.includes('HVCI') && tag.length > 3
                );
                if (meaningfulTag) return meaningfulTag;
            }
            return 'Unknown Driver';
        }
        
        async function updateDriversJSON() {
            console.log('Loading drivers database...');
            const driversData = JSON.parse(fs.readFileSync(DRV_JSON_PATH, 'utf8'));
            
            const { allowedHashes, blockedHashes, hashDetails } = await processCSV();
            
            let newlyPassedCount = 0;
            let newlyBlockedCount = 0;
            let newlyUnknownCount = 0;
            let totalHvciPassedCount = 0;
            let totalHvciBlockedCount = 0;
            let totalHvciUnknownCount = 0;
            
            const changes = {
                newlyPassed: [],
                newlyBlocked: [],
                newlyUnknown: [],
                summary: []
            };
            
            driversData.forEach(driver => {
                if (driver.KnownVulnerableSamples) {
                    driver.KnownVulnerableSamples.forEach(sample => {
                        const sampleHashes = [
                            sample.MD5?.toLowerCase(),
                            sample.SHA1?.toLowerCase(), 
                            sample.SHA256?.toLowerCase(),
                            sample.Authentihash?.MD5?.toLowerCase(),
                            sample.Authentihash?.SHA1?.toLowerCase(),
                            sample.Authentihash?.SHA256?.toLowerCase()
                        ].filter(Boolean);
                        
                        let isAllowed = false;
                        let isBlocked = false;
                        let matchedHash = null;
                        let matchedHashType = null;
                        
                        // Check if any hash is in the allowed or blocked lists
                        for (const hash of sampleHashes) {
                            if (allowedHashes.has(hash)) {
                                isAllowed = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                            if (blockedHashes.has(hash)) {
                                isBlocked = true;
                                matchedHash = hash;
                                matchedHashType = hashDetails.get(hash)?.type || 'Unknown';
                                break;
                            }
                        }
                        
                        // HVCI tagging logic:
                        // - If driver has Allowed status → HVCI PASSED
                        // - If driver has Blocked status → HVCI BLOCKED
                        // - If driver is not in CSV → HVCI UNKNOWN
                        
                        if (!driver.Tags) {
                            driver.Tags = [];
                        }
                        
                        const hasHVCIPassed = driver.Tags.includes('HVCI PASSED');
                        const hasHVCIBlocked = driver.Tags.includes('HVCI BLOCKED');
                        const hasHVCIUnknown = driver.Tags.includes('HVCI UNKNOWN');
                        
                        if (isAllowed && !hasHVCIPassed) {
                            // Driver is allowed by HVCI policy
                            driver.Tags.push('HVCI PASSED');
                            newlyPassedCount++;
                            
                            const driverName = getDriverDisplayName(driver, sample);
                            changes.newlyPassed.push({
                                driverId: driver.Id,
                                driverName,
                                hash: matchedHash.toUpperCase(),
                                hashType: matchedHashType,
                                company: sample.Company || 'Unknown'
                            });
                            
                            // Remove other HVCI tags
                            const blockedIndex = driver.Tags.indexOf('HVCI BLOCKED');
                            if (blockedIndex > -1) driver.Tags.splice(blockedIndex, 1);
                            const unknownIndex = driver.Tags.indexOf('HVCI UNKNOWN');
                            if (unknownIndex > -1) driver.Tags.splice(unknownIndex, 1);
                            
                        } else if (isBlocked && !hasHVCIBlocked) {
                            // Driver is blocked by HVCI policy
                            driver.Tags.push('HVCI BLOCKED');
                            newlyBlockedCount++;
                            
                            const driverName = getDriverDisplayName(driver, sample);
                            changes.newlyBlocked.push({
                                driverId: driver.Id,
                                driverName,
                                hash: matchedHash.toUpperCase(),
                                hashType: matchedHashType,
                                company: sample.Company || 'Unknown'
                            });
                            
                            // Remove other HVCI tags
                            const passedIndex = driver.Tags.indexOf('HVCI PASSED');
                            if (passedIndex > -1) driver.Tags.splice(passedIndex, 1);
                            const unknownIndex = driver.Tags.indexOf('HVCI UNKNOWN');
                            if (unknownIndex > -1) driver.Tags.splice(unknownIndex, 1);
                            
                        } else if (!isAllowed && !isBlocked && !hasHVCIUnknown) {
                            // Driver is not in CSV, status unknown
                            driver.Tags.push('HVCI UNKNOWN');
                            newlyUnknownCount++;
                            
                            const driverName = getDriverDisplayName(driver, sample);
                            const firstHash = sampleHashes[0] || 'Unknown';
                            changes.newlyUnknown.push({
                                driverId: driver.Id,
                                driverName,
                                hash: firstHash.toUpperCase(),
                                hashType: 'N/A',
                                company: sample.Company || 'Unknown'
                            });
                            
                            // Remove other HVCI tags
                            const passedIndex = driver.Tags.indexOf('HVCI PASSED');
                            if (passedIndex > -1) driver.Tags.splice(passedIndex, 1);
                            const blockedIndex = driver.Tags.indexOf('HVCI BLOCKED');
                            if (blockedIndex > -1) driver.Tags.splice(blockedIndex, 1);
                        }
                        
                        // Count totals
                        if (driver.Tags.includes('HVCI PASSED')) {
                            totalHvciPassedCount++;
                        }
                        if (driver.Tags.includes('HVCI BLOCKED')) {
                            totalHvciBlockedCount++;
                        }
                        if (driver.Tags.includes('HVCI UNKNOWN')) {
                            totalHvciUnknownCount++;
                        }
                    });
                }
            });
            
            // Add metadata
            if (!driversData._metadata) {
                driversData._metadata = {};
            }
            driversData._metadata.hvciCheck = {
                lastCheck: new Date().toISOString(),
                newlyPassedDrivers: newlyPassedCount,
                newlyBlockedDrivers: newlyBlockedCount,
                newlyUnknownDrivers: newlyUnknownCount,
                totalHvciPassed: totalHvciPassedCount,
                totalHvciBlocked: totalHvciBlockedCount,
                totalHvciUnknown: totalHvciUnknownCount,
                source: 'Microsoft HVCI Policy',
                triggerEvent: process.env.GITHUB_EVENT_NAME || 'manual'
            };
            
            // Create detailed summary
            let summaryContent = '# HVCI Tag Update Summary\n\n';
            summaryContent += `**Date:** ${new Date().toISOString()}\n`;
            summaryContent += `**Trigger:** ${process.env.GITHUB_EVENT_NAME || 'manual'}\n`;
            summaryContent += `**Method:** Trail of Bits HVCI Policy Analysis\n`;
            summaryContent += `**Newly Passed Drivers:** ${newlyPassedCount}\n`;
            summaryContent += `**Newly Blocked Drivers:** ${newlyBlockedCount}\n`;
            summaryContent += `**Newly Unknown Drivers:** ${newlyUnknownCount}\n`;
            summaryContent += `**Total HVCI PASSED:** ${totalHvciPassedCount}\n`;
            summaryContent += `**Total HVCI BLOCKED:** ${totalHvciBlockedCount}\n`;
            summaryContent += `**Total HVCI UNKNOWN:** ${totalHvciUnknownCount}\n\n`;
            
            summaryContent += '## Analysis Method\n\n';
            summaryContent += 'This analysis uses the Trail of Bits HVCI check script which:\n';
            summaryContent += '1. Extracts the actual Microsoft HVCI policy from the system\n';
            summaryContent += '2. Checks each driver against hash-based rules\n';
            summaryContent += '3. Validates signer certificate chains\n';
            summaryContent += '4. Applies version-based blocking rules\n';
            summaryContent += '5. Determines final allowed/blocked status\n\n';
            summaryContent += '**Tagging Logic:**\n';
            summaryContent += '- Drivers with "Allowed" status → **HVCI PASSED**\n';
            summaryContent += '- Drivers with "Blocked" status → **HVCI BLOCKED**\n';
            summaryContent += '- Drivers not in analysis results → **HVCI UNKNOWN**\n\n';
            
            if (changes.newlyPassed.length > 0) {
                summaryContent += '## Newly Passed Drivers\n\n';
                summaryContent += '*These drivers passed the current HVCI policy:*\n\n';
                changes.newlyPassed.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n\n`;
                });
            }
            
            if (changes.newlyBlocked.length > 0) {
                summaryContent += '## Newly Blocked Drivers\n\n';
                summaryContent += '*These drivers are blocked by the current HVCI policy:*\n\n';
                changes.newlyBlocked.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - ${item.hashType}: \`${item.hash}\`\n`;
                    summaryContent += `   - Company: ${item.company}\n\n`;
                });
            }
            
            if (changes.newlyUnknown.length > 0) {
                summaryContent += '## Newly Unknown Drivers\n\n';
                summaryContent += '*These drivers were not found in the HVCI policy analysis:*\n\n';
                changes.newlyUnknown.forEach((item, index) => {
                    summaryContent += `${index + 1}. **${item.driverName}**\n`;
                    summaryContent += `   - Driver ID: \`${item.driverId}\`\n`;
                    summaryContent += `   - Status: Not in HVCI policy data\n`;
                    summaryContent += `   - Company: ${item.company}\n\n`;
                });
            }
            
            if (changes.newlyPassed.length === 0 && changes.newlyBlocked.length === 0 && changes.newlyUnknown.length === 0) {
                summaryContent += '## No Changes\n\nNo new drivers were tagged in this update.\n';
                summaryContent += 'All drivers already have current HVCI policy status.\n';
            }
            
            fs.writeFileSync('hvci-summary.md', summaryContent);
            
            // Save updated data
            const totalChanges = newlyPassedCount + newlyBlockedCount + newlyUnknownCount;
            if (totalChanges > 0) {
                console.log(`Updated ${totalChanges} drivers with HVCI tags (${newlyPassedCount} passed, ${newlyBlockedCount} blocked, ${newlyUnknownCount} unknown)`);
                fs.writeFileSync(DRV_JSON_PATH, JSON.stringify(driversData, null, 2));
                
                // Set output for GitHub Actions
                console.log(`::set-output name=changes::${totalChanges}`);
                console.log(`::set-output name=newly_passed::${newlyPassedCount}`);
                console.log(`::set-output name=newly_blocked::${newlyBlockedCount}`);
                console.log(`::set-output name=newly_unknown::${newlyUnknownCount}`);
            } else {
                console.log('No new HVCI tags to add');
                // Still update metadata
                fs.writeFileSync(DRV_JSON_PATH, JSON.stringify(driversData, null, 2));
                console.log(`::set-output name=changes::0`);
            }
            
            console.log(`Total HVCI status: ${totalHvciPassedCount} passed, ${totalHvciBlockedCount} blocked, ${totalHvciUnknownCount} unknown`);
        }
        
        updateDriversJSON().catch(console.error);
        EOF
        
    - name: Execute HVCI tagging script
      id: hvci-check
      run: node hvci-tagger.js
      
    - name: Display results
      run: |
        echo "=========================================="
        echo "           HVCI UPDATE RESULTS"
        echo "=========================================="
        if [ -f "hvci-summary.md" ]; then
          echo "HVCI check completed successfully!"
          echo ""
          
          # Extract key metrics from summary
          if grep -q "Newly Passed Drivers:" hvci-summary.md; then
            NEWLY_PASSED=$(grep "Newly Passed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly passed drivers: $NEWLY_PASSED"
          fi
          
          if grep -q "Newly Blocked Drivers:" hvci-summary.md; then
            NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly blocked drivers: $NEWLY_BLOCKED"
          fi
          
          if grep -q "Newly Unknown Drivers:" hvci-summary.md; then
            NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Newly unknown drivers: $NEWLY_UNKNOWN"
          fi
          
          if grep -q "Total HVCI PASSED:" hvci-summary.md; then
            TOTAL_PASSED=$(grep "Total HVCI PASSED:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total passed drivers: $TOTAL_PASSED"
          fi
          
          if grep -q "Total HVCI BLOCKED:" hvci-summary.md; then
            TOTAL_BLOCKED=$(grep "Total HVCI BLOCKED:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total blocked drivers: $TOTAL_BLOCKED"
          fi
          
          if grep -q "Total HVCI UNKNOWN:" hvci-summary.md; then
            TOTAL_UNKNOWN=$(grep "Total HVCI UNKNOWN:" hvci-summary.md | grep -o '[0-9]\+' | head -1)
            echo "Total unknown drivers: $TOTAL_UNKNOWN"
          fi
          
          echo ""
          echo "Detailed summary available in workflow summary."
        else
          echo "No summary file generated - check may have failed"
        fi
        echo "=========================================="
      
    - name: Check for changes
      id: git-check
      run: |
        git diff --exit-code data/drv.json || echo "changed=true" >> $GITHUB_OUTPUT
        
    - name: Commit and push changes
      if: steps.git-check.outputs.changed == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add data/drv.json
        
        # Create detailed commit message
        COMMIT_MSG="Update HVCI tags using Trail of Bits policy analysis"
        
        if [ -f "hvci-summary.md" ]; then
          # Extract summary info for commit message
          NEWLY_PASSED=$(grep "Newly Passed Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_BLOCKED=$(grep "Newly Blocked Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          NEWLY_UNKNOWN=$(grep "Newly Unknown Drivers:" hvci-summary.md | grep -o '[0-9]\+' | head -1 || echo "0")
          
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Trail of Bits HVCI policy extraction
        - Newly passed drivers: $NEWLY_PASSED
        - Newly blocked drivers: $NEWLY_BLOCKED
        - Newly unknown drivers: $NEWLY_UNKNOWN
        - Analysis includes hash, signer, and version checks"
        else
          COMMIT_MSG="$COMMIT_MSG
        
        - Updated $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - Triggered by: ${{ github.event_name }}
        - Method: Trail of Bits HVCI policy extraction"
        fi
        
        git commit -m "$COMMIT_MSG"
        
        echo "Pushing changes..."
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create workflow summary
      run: |
        echo "## HVCI Tag Update Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Date:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "**Previous workflow:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous workflow status:** ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "**Source:** [Trail of Bits HVCI Analysis](https://github.com/trailofbits/HVCI-loldrivers-check)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Add detailed results from the check script
        if [ -f "hvci-summary.md" ]; then
          cat hvci-summary.md >> $GITHUB_STEP_SUMMARY
        else
          echo "No summary file generated - check may have failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "**About HVCI**: Hypervisor-protected Code Integrity (HVCI) uses hardware virtualization features to protect kernel mode processes against the injection and execution of malicious or unverified code. This analysis extracts the actual HVCI policy from the system and performs comprehensive checks including hash validation, certificate chain analysis, and version-based rules." >> $GITHUB_STEP_SUMMARY
        
    - name: Upload summary artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: hvci-update-summary
        path: |
          hvci-summary.md
          hvci_drivers.csv
        retention-days: 30
